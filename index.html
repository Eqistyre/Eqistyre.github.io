<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SakuraNeko</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="SakuraNeko">
<meta property="og:url" content="http://eqistyre.github.io/index.html">
<meta property="og:site_name" content="SakuraNeko">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SakuraNeko">
<meta name="twitter:description">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://chuantu.biz/t2/18/1446819674x1822611272.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">张仲昊</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Eqistyre" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.talisk.cn">talisk斯温</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">人间二十年,花鸟风月</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">张仲昊</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://chuantu.biz/t2/18/1446819674x1822611272.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">张仲昊</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Eqistyre" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-DataStructure(5)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/25/DataStructure(5)/" class="article-date">
  	<time datetime="2015-12-25T14:40:35.000Z" itemprop="datePublished">2015-12-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/25/DataStructure(5)/">DataStructure(5)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="平衡二叉树">平衡二叉树</h3><p>“平衡因子（Balance Factor, 简BF）”：BF(T) = h<sub>L</sub> - h<sub>R</sub>。<br><br>平衡二叉树(Balanced Binary Tree) (AVL树)：空树，或者任一结点左、右子树高度差的绝对值不超过1，即|BF(T)| ≤ 1。</p>
<h3 id="平衡二叉树的调整">平衡二叉树的调整</h3><p><img src="https://raw.githubusercontent.com/AirOil/Test_X/bf0bff39b0ea74be9ad67b971c1062e0091483c9/imgs/二叉树.png" alt="二叉树的调整"></p>
<p>这个放图了，不放图的话实在是说不清楚，哈哈～</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-DataStructure(4)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/22/DataStructure(4)/" class="article-date">
  	<time datetime="2015-12-22T14:40:35.000Z" itemprop="datePublished">2015-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/22/DataStructure(4)/">DataStructure(4)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Tree（上）">Tree（上）</h3><h5 id="basic_operation">basic operation</h5><p>Searching</p>
<p><li>Static search</li></p>
<p>Method one: sequential search</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> SequentialSearch (staticTable *Tb1, ElementType K) &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	Tb1-&gt;Element[<span class="number">0</span>] = K; <span class="comment">//Set up sentry</span></span><br><span class="line">	<span class="keyword">for</span>(i = Tb1-&gt;Length; Tb-&gt;Element[i] != K; i--);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序查找1算法的时间复杂度是O(n)。</p>
<p>设立哨兵(set uo sentry)是一种防止数组越界的好方法，我们可以看下面的问题：</p>
<p>如果我们把下面的i &gt; 0去掉会发生什么情况呢？</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> SequentialSearch(<span class="keyword">Static</span> Table *Tbl, ElementType K) &#123;</span><br><span class="line">	<span class="built_in">int</span> i<span class="comment">;</span></span><br><span class="line">	<span class="keyword">for</span>(i = Tbl-&gt;Length<span class="comment">; i &gt; 0 &amp;&amp; Tbl-&gt;Element[i]! = k; i--);</span></span><br><span class="line">	<span class="keyword">return</span> i<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会发现，假如我们要查询元素K的话，如果K是没有的，那么便就会发生越界的情况，因为永远不可能有<code>Tbl-&gt;Element[i] != k</code>情况发生。数组越界会占用其它内存空间。</p>
<p>Method two: Binary Search(二分查找)</p>
<p>假设n个数据元素的关键字满足有序（比如：小到大）k<sub>1</sub> &lt; k<sub>2</sub> &lt; k<sub>3</sub> &lt; … &lt; k<sub>n</sub>， 并且是连续存放的（数组）， 那么可以进行二分查找。</p>
<p>如果查询不到则会出现left &gt; right这种情况！</p>
<p>这种方法让我想起了小时候和父亲玩网游里的一个小游戏呢。 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int <span class="type">BinarySearch</span>(<span class="type">StaticTable</span> * <span class="type">Tbl</span>, <span class="type">ElementType</span> <span class="type">K</span>) &#123;</span><br><span class="line">	int <span class="keyword">left</span>, <span class="keyword">right</span>, mid, <span class="type">NoFound</span> = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">left</span> = <span class="number">1</span>; <span class="comment">//初始化左边界</span></span><br><span class="line">	<span class="keyword">right</span> = <span class="type">Tbl</span>-&gt;<span class="type">Length</span>; <span class="comment">//初始化右边界</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">left</span> &lt;= <span class="keyword">right</span>) &#123;</span><br><span class="line">		mid = (<span class="keyword">left</span> + <span class="keyword">right</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="type">K</span> &lt; <span class="type">Tbl</span>-&gt;<span class="type">Element</span>[mid]) &#123;</span><br><span class="line">			<span class="keyword">right</span> = mid - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">K</span> &gt; <span class="type">Tbl</span>-&gt;<span class="type">Element</span>[mid]) &#123;</span><br><span class="line">			<span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">NotFound</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分法查找算法具有对数的时间复杂度O(logN)。</p>
<p>启示：<br><br>11个元素的二分查找判定树<br><br>判定树上每个结点的查找次数刚好为该结点所在的层数；查找成功时查找次数不会超过判定树的深度；n个节点的判定树的深度为[log<sub>2</sub>n]+1。ASL(Average Search Length) = (各个层数上节点数^层数) / 总结点数；</p>
<p><li>Dynamic search</li></p>
<p>树(Tree)的定义:</p>
<p>1.子树是不想交的<br><br>2.除了根结点外，每个结点有且只有一个父结点<br><br>3.一颗N个结点的树有N-1条边（树是保证边最少的一种方式）<br></p>
<p>树(Tree)的一些基本术语:<br>1.结点的度(Degree)：结点的子树个数。<br><br>2.树的度：树的所有结点中最大的度数。<br><br>3.叶结点(Leaf)：度为0的结点。<br><br>4.父结点(Parent)：有子树的结点是其子树的根结点的父节点。<br><br>5.子结点：若A结点是B结点的父结点，则称B结点是A结点的字结点；子结点也称为孩子结点(Child)。：<br><br>6.兄弟结点(sibling)：具有同一父节点的各结点彼此是兄弟结点。<br></p>
<p>树(Tree)的表示:</p>
<p>不能采取数组储存，因为数组储存会有无法识别的问题。也不适合采用链状储存，因为每个结点含有的指针数不一样，无法使用统一的方法去表示这些指针。</p>
<p>儿子－兄弟表示法<br><br>两个空间，一个指向下一代，一个指向其兄弟，这样一搞看起来像是变位的二叉树了。</p>
<p>二叉树（有左右之分）分类：<br><br>斜二叉树（Skewed Binary Tree）：只有一条边的二叉树<br><br>完美二叉树，满二叉树（Perfect Binary Tree）：二分，且叶结点不残缺<br><br>完全二叉树（Full Binary Tree）：有n个结点的二叉树，对树中结点按从上至下、从左至右的顺序进行编号，编号为i (1 ≤ i ≤ n)结点与满二叉树中编号为i结点在二叉树中位置相同<br></p>
<p>在二叉树中，叶结点的个数 ＝ 有两个儿子结点的个数 ＋ 1。</p>
<p>二叉树的抽象数据类型定义<br><br>类型名称：二叉树<br><br>数据对象集：一个有穷的结点集合。若不为空，则由根结点和其左、右二叉子树组成<br><br>操作集：BT ∈ BinTree, Item ∈ ElementType, 重要操作有：<br><br>1、Boolean IsEmpty(BinTree BT)：判断BT是否为空；<br><br>2、void Traversal(BinTree BT)：遍历，按某顺序访问每个结点；<br><br>3、BinTree CreatBinTree( )：创建一个二叉树。<br></p>
<p>常用的遍历方法有：</p>
<p><li>void PreOrderTraversal(BinTree BT):先序－－根、左子树、右子树；</li></p>
<p><li>void InOderTraversal(BinTree BT):中序－－左子树、根、右子树；</li></p>
<p><li>void PostTraversal(BinTree BT):后序－－左子树、右子树、根；</li></p>
<p><li>void LevelTraversal(BinTree BT):层次遍历，从上倒下、从左到右；<br><br> <em> 这里的先、中、后指的是根！</em></li></p>
<h4 id="二叉树的储存结构">二叉树的储存结构</h4><p>1.顺序储存结构（在计算机中用一组地址连续的储存单元依次储存呢线性表的各个数据元素，称作线性表的顺序储存结构）</p>
<p>完全二叉树：特别适合数组储存！因为不缺结点，对于一般二叉树我们可以补全结点，不过会有一堆堆的空间浪费！对了，这里还是会有规律的～<br><br>2.链表储存（儿子－－兄弟储存法）</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//说真的我真心觉得这种方式好奇怪呀。就是说我们创建了一个结构体TreeNode 然后我们让 *<span class="keyword">BinTree </span>指向它，这里的Typedef的意思不再是起别名而是说后面的*<span class="keyword">BinTree </span>= TreeNode 也就是说<span class="keyword">BinTree指向TreeNode</span><br><span class="line"></span><span class="label">typedef</span> <span class="keyword">struct </span>TreeNode *<span class="keyword">BinTree;</span><br><span class="line"></span><span class="label">typedef</span> <span class="keyword">Bintree </span>Position<span class="comment">;</span></span><br><span class="line"><span class="keyword">struct </span>TreeNode &#123;</span><br><span class="line">	ElementType <span class="preprocessor">Data</span><span class="comment">;</span></span><br><span class="line">	<span class="keyword">BinTree </span>Left<span class="comment">;</span></span><br><span class="line">	<span class="keyword">BinTree </span>Right<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的递归遍历">二叉树的递归遍历</h4><p><1>先序遍历</1></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">void</span> PreOrderTraversal( <span class="keyword">BinTree </span><span class="keyword">BT) </span>&#123;</span><br><span class="line">	<span class="preprocessor">if</span> (<span class="keyword">BT) </span>&#123;</span><br><span class="line">		printf(<span class="string">"%d"</span>, <span class="keyword">BT-&gt;Data);</span><br><span class="line"></span>		preOrderTraversal(<span class="keyword">BT-&gt;Left);</span><br><span class="line"></span>		preOrderTraversal(<span class="keyword">BT-&gt;Right);</span><br><span class="line"></span>	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><2>中序遍历</2></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">void</span> InOrderTraversal( <span class="keyword">BinTree </span><span class="keyword">BT) </span>&#123;</span><br><span class="line">	<span class="preprocessor">if</span> (<span class="keyword">BT) </span>&#123;</span><br><span class="line">		InOrderTraversal(<span class="keyword">BT-&gt;left);</span><br><span class="line"></span>		printf(<span class="string">"%d"</span>, <span class="keyword">BT-&gt;Data);</span><br><span class="line"></span>		InOrderTraversal(<span class="keyword">BT-&gt;Right);</span><br><span class="line"></span>	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在中序遍历中会把左结点优先，也就是说根结点后来读，先读左边的左边（如果有左边的话）。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">void</span> PostOrderTraversal( <span class="keyword">BinTree </span><span class="keyword">BT) </span>&#123;</span><br><span class="line">	<span class="preprocessor">if</span> (<span class="keyword">BT) </span>&#123;</span><br><span class="line">		PostOrderTraversal(<span class="keyword">BT-&gt;left);</span><br><span class="line"></span>		PostOrderTraversal(<span class="keyword">BT-&gt;right);</span><br><span class="line"></span>		printf(<span class="string">"%d"</span>, <span class="keyword">BT-&gt;Data);</span><br><span class="line"></span>	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>先序、中序和后序遍历过程：遍历过程中经过的路线一样，知识访问各个结点的时机不同!</em></p>
<h4 id="二叉树的非递归遍历">二叉树的非递归遍历</h4><p>非递归算法实现的基本思路：使用堆栈。</p>
<p>中序遍历非递归遍历算法<br></p>
<p><li>遇到一个结点，就把它压栈，并去遍历它的左子树；</li></p>
<p><li>党左子树遍历结束后，从栈顶弹出这个结点并访问它；</li></p>
<p><li>然后按其右指针再去遍历该结点的右子树；</li></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void InOrderTraversal( BinTree BT ) &#123;</span><br><span class="line">	BinTree <span class="literal">T</span> = BT;</span><br><span class="line">	Stack S = CreatStack(MaxSize);</span><br><span class="line">	//判定条件树不空，堆栈不空</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">T</span> || !IsEmpty(S)) &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">T</span>) &#123;</span><br><span class="line">			push(S, <span class="literal">T</span>);</span><br><span class="line">			<span class="literal">T</span> = <span class="literal">T</span>-&gt;Left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!IsEmpty(S)) &#123;</span><br><span class="line">			<span class="literal">T</span> = Pop(S);</span><br><span class="line">			printf(<span class="string">"%5d"</span>, <span class="literal">T</span>-&gt;Data);</span><br><span class="line">			<span class="literal">T</span> = <span class="literal">T</span>-&gt;Right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="层序遍历">层序遍历</h4><p>二叉树遍历的核心问题：二维结构的线性话（把二维化为一维）<br></p>
<p><li>从结点访问其左、右儿子结点</li></p>
<p><li>访问左儿子后，右儿子结点怎么办？<br>需要一个储存结构保存暂时不访问的结点，我们应该选用：堆栈、队列。<br></li></p>
<p><li>队列实现：遍历从根结点开始，首先将根结点入队，然后开始执行循环：结点出队、访问该结点、其左右儿子入队。</li></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">void</span> LevelOrderTraversal ( <span class="keyword">BinTree </span><span class="keyword">BT) </span>&#123;</span><br><span class="line">	Queue Q<span class="comment">;</span></span><br><span class="line">	<span class="keyword">BinTree </span>T<span class="comment">;</span></span><br><span class="line">	<span class="preprocessor">if</span> (!<span class="keyword">BT) </span>&#123;</span><br><span class="line">		return<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	Q = CreatQueue(MaxSize)<span class="comment">;</span></span><br><span class="line">	<span class="keyword">addQ(Q, </span><span class="keyword">BT);</span><br><span class="line"></span>	<span class="preprocessor">while</span> (!IsEmptyQ(Q)) &#123;</span><br><span class="line">		T = DeleteQ(Q)<span class="comment">;</span></span><br><span class="line">		printf(<span class="string">"%d\n"</span>, T-&gt;<span class="preprocessor">Data</span>)<span class="comment">;</span></span><br><span class="line">		<span class="preprocessor">if</span>(T-&gt;Left) &#123;</span><br><span class="line">			<span class="keyword">AddQ(Q, </span>T-&gt;Left)<span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="preprocessor">if</span>(T-&gt;Right) &#123;</span><br><span class="line">			<span class="keyword">AddQ(Q, </span>T-&gt;Right)<span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树">二叉搜索树</h4><p>查找问题：<br></p>
<p><li>静态查找与动态查找</li></p>
<p><li>针对动态查找，数据如何组织？</li></p>
<p>二叉搜索树（BST, Binary Search Tree）也称为二叉排序树或二叉查找树，二叉搜索树，若不为空，满足以下性质：<br></p>
<p><li>1.非空左子树所有键值小于其根结点的键值。</li></p>
<p><li>2.非空右子树所有键值大于其根结点的键值。</li></p>
<p><li>3.左、右子树都是二叉搜索树。</li></p>
<h4 id="二叉搜索树操作的特别函数：">二叉搜索树操作的特别函数：</h4><p>Position Find(ElementType X, BinTree BST)：从二叉搜索树BST中查找元素X,返回其所在结点的地址；</p>
<p>Position FinMin(BinTree BST)：从二叉搜索树BST中查找并返回最小元素所在结点的地址；</p>
<p>Postion FindMax(BinTree BST)：从二叉搜索树BST中查找并返回最大元素所在的结点。</p>
<p>由于非递归函数的执行效率高，可将“尾递归”函数改为迭代函数。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Postion Find(ElementType X, BinTree BST) &#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="subst">!</span>BST) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(X &gt; BST<span class="subst">-&gt;</span><span class="built_in">Data</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Find(X, BST<span class="subst">-&gt;</span>Right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST<span class="subst">-&gt;</span>Left) &#123;</span><br><span class="line">		<span class="keyword">return</span> Find(X, BST<span class="subst">-&gt;</span>Left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> BST;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现这是一种“尾递归”，由于非递归函数的执行效率高，可将“尾递归”函数改成迭代函数。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Position</span> <span class="keyword">IterFind(ElementType </span>X, <span class="keyword">BinTreeBST) </span>&#123;</span><br><span class="line">	<span class="preprocessor">while</span>(<span class="keyword">BST) </span>&#123;</span><br><span class="line">		<span class="preprocessor">if</span>( X &gt; <span class="keyword">BST </span>-&gt; <span class="preprocessor">Data</span>) &#123;</span><br><span class="line">			<span class="keyword">BST </span>= <span class="keyword">BST-&gt;Right;</span><br><span class="line"></span>		&#125; <span class="preprocessor">else</span> <span class="preprocessor">if</span>(x &lt; <span class="keyword">BST-&gt; </span><span class="preprocessor">Data</span>) &#123;</span><br><span class="line">			<span class="keyword">BST </span>= <span class="keyword">BST-&gt;Left;</span><br><span class="line"></span>		&#125;</span><br><span class="line">		<span class="preprocessor">else</span> &#123;</span><br><span class="line">			return <span class="keyword">BST;</span><br><span class="line"></span>		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Position</span> FindMin(<span class="keyword">BinTree </span><span class="keyword">BST) </span>&#123;</span><br><span class="line">	<span class="preprocessor">if</span>(!<span class="keyword">BST) </span>&#123;</span><br><span class="line">		return NULL<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="preprocessor">else</span> <span class="preprocessor">if</span>(!<span class="keyword">BST-&gt;Left) </span>&#123;</span><br><span class="line">		return <span class="keyword">BST;</span><br><span class="line"></span>	&#125;</span><br><span class="line">	<span class="preprocessor">else</span> &#123;</span><br><span class="line">		return FindMin(<span class="keyword">BST-&gt;Left);</span><br><span class="line"></span>	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Position</span> FindMax(<span class="keyword">BinTree </span><span class="keyword">BST) </span>&#123;</span><br><span class="line">	<span class="preprocessor">if</span>(<span class="keyword">BST) </span>｛</span><br><span class="line">		<span class="preprocessor">while</span>( <span class="keyword">BST-&gt;Right) </span>&#123;</span><br><span class="line">			<span class="keyword">BST </span>= <span class="keyword">BST-&gt;Right</span><br><span class="line"></span>		&#125;</span><br><span class="line">	｝</span><br><span class="line">	return <span class="keyword">BST;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树的插入">二叉搜索树的插入</h4><p>[分析]我们要找到插入的位置，可以使用Find方法。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BinTree </span>Insert( ElementType X, <span class="keyword">BinTree </span><span class="keyword">BST) </span>&#123;</span><br><span class="line">	<span class="preprocessor">if</span>(!<span class="keyword">BST) </span>&#123;</span><br><span class="line">		//若原树为空，生成并返回一个结点的二叉搜索树</span><br><span class="line">		<span class="keyword">BST </span>= malloc(sizeof(<span class="keyword">struct </span>TreeNode))<span class="comment">;</span></span><br><span class="line">		<span class="keyword">BST-&gt;Data </span>= X<span class="comment">;</span></span><br><span class="line">		<span class="keyword">BST-&gt;Left </span>= <span class="keyword">BST-&gt;Right </span>= NULL</span><br><span class="line">	&#125; <span class="preprocessor">else</span> &#123;</span><br><span class="line">		<span class="preprocessor">if</span>(X &lt; <span class="keyword">BST-&gt;Data) </span>&#123;</span><br><span class="line">			<span class="keyword">BST-&gt;Left </span>= Insert(X, <span class="keyword">BST-&gt;Left);</span><br><span class="line"></span>			&#125;</span><br><span class="line">		<span class="preprocessor">else</span> <span class="preprocessor">if</span>(X &gt; <span class="keyword">BST-&gt;Data) </span>&#123;</span><br><span class="line">			<span class="keyword">BST-&gt;Right </span>= Insert(X, <span class="keyword">BST-&gt;Right);</span><br><span class="line"></span>		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="keyword">BST;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树的删除">二叉搜索树的删除</h4><p>考虑三种情况：<br></p>
<p><li>要删除的是叶结点：直接删除，并再修改其父节点指针为NULL。<br></li></p>
<p><li>要删除的结点只有一个孩子结点：将其父节点的指针指向要删除的孩子结点。<br></li></p>
<p><li>要删除的结点有左、右两颗子树：用另一结点替代被删除结点：<em>右子树的最小元素</em>或者<em>左子树的最大元素</em>。<br></li></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BinTree Delete(ElementType X, BinTree BST) &#123;</span><br><span class="line">	Position Tmp;</span><br><span class="line">	<span class="keyword">if</span>(<span class="subst">!</span>BST) &#123;</span><br><span class="line">		printf(<span class="string">"要删除的元素未找到"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; BST<span class="subst">-&gt;</span><span class="built_in">Data</span>) &#123;</span><br><span class="line">		BST<span class="subst">-&gt;</span>Left = Delete(X, BST<span class="subst">-&gt;</span>Right);<span class="comment">//左子树递归删除</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; BST<span class="subst">-&gt;</span><span class="built_in">Data</span>) &#123;</span><br><span class="line">		BST<span class="subst">-&gt;</span>Right = Delete(X, BST<span class="subst">-&gt;</span>Right);<span class="comment">//右子树递归删除</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(BST<span class="subst">-&gt;</span>Left <span class="subst">&amp;&amp;</span> BST<span class="subst">-&gt;</span>Right) &#123;</span><br><span class="line">		Tmp = FindMin(BST<span class="subst">-&gt;</span>Right);</span><br><span class="line">		BST<span class="subst">-&gt;</span><span class="built_in">Data</span> = Tmp<span class="subst">-&gt;</span><span class="built_in">Data</span>;</span><br><span class="line">		BST<span class="subst">-&gt;</span>Right = Delete(BST<span class="subst">-&gt;</span><span class="built_in">Data</span>, BST<span class="subst">-&gt;</span>Right);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Tmp = BST;</span><br><span class="line">			<span class="keyword">if</span>(<span class="subst">!</span>BST<span class="subst">-&gt;</span>Left) &#123;</span><br><span class="line">				BST = BST<span class="subst">-&gt;</span>Right;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="subst">!</span>BST<span class="subst">-&gt;</span>Right) &#123;</span><br><span class="line">				BST = BST<span class="subst">-&gt;</span>Left;</span><br><span class="line">			&#125;</span><br><span class="line">			free(Tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-SICP(1)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/22/SICP(1)/" class="article-date">
  	<time datetime="2015-12-22T14:40:35.000Z" itemprop="datePublished">2015-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/22/SICP(1)/">SICP读书笔记(1)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言(Preface)">前言(Preface)</h3><p>我又开坑了，我要成为一代坑王了，对这个坑的期望是，一天一小节，这个好像还是挺有难度的＝＝。哦对，寒假的话还要把以前的坑给填完＝＝。事情好多呀！～。</p>
<h2 id="第一章_构造过程抽象">第一章 构造过程抽象</h2><h3 id="程序设计的基本元素">程序设计的基本元素</h3><p>一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该成为一种框架，使我们能够在其中组织自己的有关计算过程的思想。这样，当我们描述一个语言时，就需要将注意力特别放在这一语言所提供的，能够将简单的认识组合起来形成更复杂认识的方法方面。每一种强有力的语言都为此提供了三种机制：</p>
<p><li>基本表达形式：用于表示语言所关心的所关心的最简单的个体。</li></p>
<p><li>组合的方法：通过它们可以从较简单的东西出发构造出复合的元素。</li></p>
<p><li>抽象的方法：通过它们可以为复合对象命名，并将它们当作单元去操作。</li></p>
<h3 id="过程与它们所产生的计算">过程与它们所产生的计算</h3><p>首先考虑由下面表达式定义的阶乘函数：</p>
<p>n! = n <em> (n-1) </em> (n-2) <em> … </em> 3 <em> 2 </em> 1</p>
<p>计算阶乘的方式有许多种，其中有一种是利用一下的认识：对于一个正整数n, n!就等于n * (n - 1)!, 然后我们就可以直接翻译成下面过程：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">factorial</span> n)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">=</span></span> n <span class="number">1</span>)</span></span><br><span class="line">			<span class="number">1</span></span><br><span class="line">			<span class="list">( * <span class="list">(<span class="keyword">factorial</span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> n <span class="number">1</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>现在让我们采用另一种不同的观点来计算阶乘。我们可以将阶乘n!的规则描述为：先乘起1和2，而后将得到的结果乘以4，这样下去直到n。更形式的说，我们要维持一个变动中的乘积product，以及一个从1到n的计数器，这一计算过程描述为counter和product的如下变化，从第一步到下一步，它们都按照下面规则改变：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">product</span> &lt;- counter * product</span><br><span class="line"><span class="title">couter</span> &lt;- counter + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到，n!也就是计数器counter超过乘积product的值。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-STL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/20/STL/" class="article-date">
  	<time datetime="2015-12-20T13:38:35.000Z" itemprop="datePublished">2015-12-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/20/STL/">C++ learning notes (7)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Preface">Preface</h3><p>STL reveale a kind of programming ways - Generic Programming, we will introduce a new module - initializer_list.</p>
<h3 id="String_Class">String Class</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//str1.cpp -- introducing the string class </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//using string constructors</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">one</span><span class="params">(<span class="string">"Lottery Winner!"</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; one &lt;&lt; endl;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">two</span><span class="params">(<span class="number">20</span>, <span class="string">'$'</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; two &lt;&lt; endl;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">three</span> <span class="params">(one)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; three &lt;&lt; endl;</span><br><span class="line">	one += <span class="string">" Oops!"</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; one &lt;&lt; endl;</span><br><span class="line">	two  = <span class="string">"Sorry! That was "</span>;</span><br><span class="line">	three[<span class="number">0</span>] = <span class="string">'P'</span>;</span><br><span class="line">	<span class="built_in">string</span> four;</span><br><span class="line">	four = two + three;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; four &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">char</span> alls[] = <span class="string">"All's Well that ends well"</span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">five</span><span class="params">(alls, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; five &lt;&lt; <span class="string">"!\n"</span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">six</span><span class="params">(alls + <span class="number">6</span>, alls + <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; six &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">seven</span><span class="params">(&amp;five[<span class="number">6</span>], &amp;five[<span class="number">10</span>])</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; seven &lt;&lt; <span class="string">"...\n"</span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">eight</span><span class="params">(four, <span class="number">7</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; eight &lt;&lt; <span class="string">" in motion!"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>we can know from str1.cpp there’re many overload in the STL.</p>
<h3 id="Smart_pointer_template_class">Smart pointer template class</h3><p>The smart pointer is class object similar with point, but this object have another function. Examples are as follows.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remodel</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp; str)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> * ps = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str);</span><br><span class="line">	……</span><br><span class="line">	str = ps;</span><br><span class="line">	<span class="keyword">return</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You may find the defect in this. when the function is called, the function will distribute the internal memory in the stack, but it won’t take back it, it may cause internal memory leaks. You may know how to resolve it, you can use <em>delete</em> to delete the memory. but there also have other problem, if you code as follws.</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void remodel(std::<span class="type">string</span> &amp; str) &#123;</span><br><span class="line">	std::<span class="type">string</span> * ps = new std::<span class="type">string</span>(str);</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">if</span> (weir_thing()) &#123;</span><br><span class="line">		throw expection();	</span><br><span class="line">	&#125;</span><br><span class="line">	str = *ps;</span><br><span class="line">	delete ps;</span><br><span class="line"><span class="command">	return</span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">When there <span class="keyword">is</span> an exception， delete won't executed, <span class="keyword">it</span> may cause internal memory leaks, so we have a better way <span class="keyword">to</span> solve this problem.</span><br><span class="line"></span><br><span class="line">Let we think <span class="keyword">if</span> a function like remodel() <span class="keyword">is</span> terminated(whatever <span class="keyword">it</span> terminated <span class="keyword">in</span> normal <span class="keyword">or</span> due <span class="keyword">to</span> abnormal termination), <span class="keyword">the</span> <span class="keyword">local</span> variable will be deleted <span class="keyword">in</span> stack memory, so <span class="keyword">the</span> pointer <span class="keyword">to</span> <span class="keyword">the</span> memory will be released. I think <span class="keyword">it</span> will make us very uplifted.</span><br><span class="line"></span><br><span class="line"><span class="comment">#### Using the smart pointer</span></span><br><span class="line">There are three smart pointer template(auto_ptr, unique_ptr <span class="keyword">and</span> shared_ptr), they all defined <span class="keyword">the</span> object similar <span class="keyword">with</span> pointer, so we can use <span class="keyword">the</span> <span class="string">"new"</span> <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">the</span> address assign <span class="keyword">to</span> this object. When <span class="keyword">the</span> smart pointer <span class="keyword">out of</span> <span class="type">date</span>, <span class="keyword">the</span> constructed function will use <span class="string">"delete"</span> <span class="keyword">to</span> free <span class="keyword">the</span> memory. Therefor, when use <span class="keyword">the</span> address <span class="keyword">the</span> <span class="string">"new"</span> returned assign <span class="keyword">to</span> these object, you won't need <span class="keyword">to</span> remember <span class="keyword">to</span> free these memory: When <span class="keyword">the</span> smart point <span class="keyword">out of</span> <span class="type">date</span>, these memory will free automatically.Examples are <span class="keyword">as</span> follows.</span><br></pre></td></tr></table></figure>
<p>懒得在代码里用英语写了，写了不容易看懂，这个还挺重要的<br>void demol() {<br>    double <em> pd = new double; //#1
    </em>pd = 25.5;                  //#2<br>    return;                      //#3<br>}</p>
<p>#1.为pd和一个double值分配储存空间，保护地址：</p>
<p>#2.将值复制到动态内存中</p>
<p>#3.删除pd,值被保存在动态内存中</p>
<p>void demo2() {<br>    auto_ptr<double> ap(new double): //#1<br>    *ap = 25.5;<br>    return;<br>}</double></p>
<p>#1.为ap和一个double值分配储存空间，保存地址</p>
<p>#2.将值复制到动态内存中</p>
<p>#3.删除ap，ap的析构函数释放动态内存<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">承浩找我还书了！！接下来的部分用中文写了！！</span><br><span class="line"></span><br><span class="line">要创建智能指针对象，必须包含有头文件memory，该文件模版定义。然后使用通常的模版语法来实例化所需要类型的指针。例如，模版<span class="built_in">auto_ptr</span>包含如下构造函数:</span><br></pre></td></tr></table></figure></p>
<p>template<class x=""> class auto_ptr {<br>public:<br>    explict auto_ptr(X* p = 0) throw();<br>    …<br>}<br>```<br>本书前面说过，throw()意味着构造函数不会引发异常：与auto_ptr一样，throw()也被摒弃。</class></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-DataStructure(3)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/18/DataStructure(3)/" class="article-date">
  	<time datetime="2015-12-18T10:38:35.000Z" itemprop="datePublished">2015-12-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/18/DataStructure(3)/">DataStructure(3)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Stack">Stack</h2><h3 id="Defination">Defination</h3><p>Stack is a kind of linear list which can be operated and constrained.</p>
<p>It only can insert and delete in the top.</p>
<p><li>Insert data: Push. <br></li></p>
<p><li>Delete data: Pop. <br></li></p>
<p><li>LIFO: Last In First Out(LIFO). <br></li></p>
<h3 id="Description_of_abstract_data_types_for_the_stack">Description of abstract data types for the stack</h3><p>Type Name: Stack<br><br>Data object set: a linear list which have more than zero elements.<br><br>Operation set: Stack S’s long is MaxSize, S ∈ Stack, The Stack elements item ∈ ElementType.<br></p>
<p><li>1.Stack CreateStack(int MaxSize): make a empty stack, maxSize is the maximum length<br></li></p>
<p><li>2.int IsFull(Stack S, int MaxSize): judge weather the stack S is filled<br></li></p>
<p><li>3.void push(Stack S, ElementType item): Press element item into the top of the stack<br></li></p>
<p><li>4.int IsEmpty (Stack S): judge weather the stack S is empty.<br></li></p>
<p><li>5.ElementType Pop(Stack S): delete and return the element in the stack top.<br></li></p>
<h3 id="Sequential_storage_implementation_of_stack">Sequential storage implementation of stack</h3><p>The Sequential storage implementation of stack always consisted of a one-dimensional array and a variable recorded the position of the stack top element.</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define MaxSize &lt;The maxium number of stores data elements&gt;</span></span><br><span class="line">typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElementType <span class="built_in">Data</span>[MaxSize];</span><br><span class="line">	int Top;	</span><br><span class="line">&#125;Stack;</span><br></pre></td></tr></table></figure>
<h3 id="Operation_examples">Operation examples</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack *PtrS, ElementType item)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Ptrs-&gt;Top == MaxSize -<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The Stack is filled"</span>);</span><br><span class="line">		<span class="keyword">return</span>;	</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		PtrS -&gt; Data[++(Ptr-&gt;Top)] = item;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack *PtrS)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//PtrS point next element!</span></span><br><span class="line">	<span class="keyword">if</span> (PtrS-&gt;Top == -<span class="number">1</span>) &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"The stack is empty"</span>);</span><br><span class="line">	 <span class="keyword">return</span> ERROR; <span class="comment">/*ERROR is a special value of ElementType, Represents the error*/</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span>(PtrS-&gt;Data[(PtrS-&gt;Top)--]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Question: Please use an array realized two stacks, the requirement is maximize the use of array space.<br><br>a smart way to solve the question:<br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DStack &#123;</span></span><br><span class="line">	ElementType Data[MaxSize];</span><br><span class="line">	<span class="keyword">int</span> Top1;</span><br><span class="line">	<span class="keyword">int</span> Top2;	</span><br><span class="line">&#125; S;</span><br><span class="line">S.Top1 = -<span class="number">1</span>;</span><br><span class="line">S.Top2 = MaxSize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">struct</span> Dstack *Ptrs, ElementType item, <span class="keyword">int</span> Tag)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Ptrs-&gt;Top2 - PtrS-&gt;Top1 == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The Stack is filled"</span>)	</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-DataStructure(2)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/17/DataStructure(2)/" class="article-date">
  	<time datetime="2015-12-17T10:38:35.000Z" itemprop="datePublished">2015-12-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/17/DataStructure(2)/">DataStructure(2)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Linear_list">Linear_list</h2><h3 id="Defination">Defination</h3><p>Linar list is one of the commonly used and simplest data structure. in a brief,a linar list is a finite sequence consist of n data element.</p>
<p>In a slightly more complex linear list, a data elements can consist of many item. under these circumstances, we usually call the elements as record, and we call the linar list which has many records as file.</p>
<p>In a linar list, we define the elements the linar list hava as it’s long, when n = 0 we called it as empty list.</p>
<p>The abstract data structure type is defined as follows：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ADT <span class="keyword">List</span> &#123;</span><br><span class="line">	Data Object: <span class="keyword">D</span> = &#123; ai | ai ∈ ElemeSet, i = 1, 2, ……, <span class="keyword">n</span> , <span class="keyword">n</span> ≥ 0&#125;</span><br><span class="line">	Data Relationship: R1 = &#123; &lt;ai-1, ai&gt; | ai-1, ai ∈ <span class="keyword">D</span>, i =2, ……, <span class="keyword">n</span>&#125;</span><br><span class="line">	Basic Operation:</span><br><span class="line">		Init <span class="keyword">List</span>(&amp;<span class="keyword">L</span>)</span><br><span class="line">			Operation Result: construct a empty linar <span class="keyword">list</span> <span class="keyword">L</span>.</span><br><span class="line">		DestoryList(&amp;<span class="keyword">L</span>)</span><br><span class="line">			Initial Condition: the linar <span class="keyword">list</span> <span class="keyword">L</span> is already existed.</span><br><span class="line">			Operation Result: destory linar <span class="keyword">list</span> <span class="keyword">L</span>.</span><br><span class="line">		ClearList(&amp;<span class="keyword">L</span>)</span><br><span class="line">			Initial Condition: the linar <span class="keyword">list</span> <span class="keyword">L</span> is already existed.</span><br><span class="line">			Operation Result: change the linar <span class="keyword">list</span> <span class="keyword">L</span> into empty <span class="keyword">list</span>.</span><br><span class="line">		ListEmpty(<span class="keyword">L</span>)</span><br><span class="line">			Initial Condition: the linar <span class="keyword">list</span> <span class="keyword">L</span> is already existed.</span><br><span class="line">			Operation Result: <span class="keyword">if</span> <span class="keyword">list</span> <span class="keyword">L</span> is a empty <span class="keyword">list</span>, <span class="keyword">return</span> TRUE, <span class="keyword">else</span> <span class="keyword">return</span> FALSE.</span><br><span class="line">		ListLength(<span class="keyword">L</span>)</span><br><span class="line">			Initial Condition: the linar <span class="keyword">list</span> <span class="keyword">L</span> is already existed.</span><br><span class="line">			Operation Result: <span class="keyword">return</span> the number of data elements <span class="keyword">in</span> <span class="keyword">L</span>.</span><br><span class="line">		GetElem(<span class="keyword">L</span>, i, &amp;<span class="keyword">e</span>)</span><br><span class="line">			Initial Condition: the linar <span class="keyword">list</span> is already existed, 1 ≤ i ≤ ListLength(<span class="keyword">L</span>).</span><br><span class="line">			Operation Result: <span class="keyword">return</span> the value of the i elements <span class="keyword">by</span> throwing <span class="keyword">e</span>.(用<span class="keyword">e</span>返回<span class="keyword">L</span>中第i个数据元素的值)</span><br><span class="line">		LocateElem(<span class="keyword">L</span>, <span class="keyword">e</span>, <span class="keyword">compare</span>())</span><br><span class="line">			Initial Condition: the linar <span class="keyword">list</span> is already existed, <span class="keyword">compare</span>() is a function judge data elements.</span><br><span class="line">			Operation Result: <span class="keyword">return</span> the first <span class="keyword">one</span> <span class="keyword">which</span> and <span class="keyword">e</span> satisfy relationship <span class="keyword">compare</span>()'s dataelements's rank. <span class="keyword">if</span> there is <span class="keyword">no</span> data elements like this, <span class="keyword">return</span> 0.(英语表述有误，尝试使用中文模式：（返回<span class="keyword">L</span>中第1个与<span class="keyword">e</span>满足关系<span class="keyword">compare</span>()的数据元素的位序。若这样的数据元素不存在，则返回值为0）)</span><br><span class="line">		PriorElem(<span class="keyword">L</span>, cur_e, &amp;pre_e)</span><br><span class="line">			Initial Condition: the linar <span class="keyword">list</span> is already existed, <span class="keyword">compare</span>()</span><br><span class="line">			Operation Result: <span class="keyword">if</span> the cur_e is <span class="keyword">L</span>'s data elements, and is not the first <span class="keyword">one</span>, then <span class="keyword">use</span> pre_e <span class="keyword">return</span> it's precursor, <span class="keyword">else</span> operation failed, pre_e is not defination(若cur_e是<span class="keyword">L</span>的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义)</span><br><span class="line">		NextElem(<span class="keyword">L</span>, cur_e, &amp;next_e)</span><br><span class="line">			Initial Condition: the linar <span class="keyword">list</span> is already existed.</span><br><span class="line">			Operation Result: </span><br><span class="line">		ListInsert(&amp;<span class="keyword">L</span>, i, <span class="keyword">e</span>)</span><br><span class="line">			Initial Condition: </span><br><span class="line">			Operation Result:</span><br><span class="line">		ListDelete(&amp;<span class="keyword">L</span>, i, <span class="keyword">e</span>)</span><br><span class="line">			Initial Condition:</span><br><span class="line">			Operation Result:</span><br><span class="line">		ListTraverse(<span class="keyword">L</span>, visit())</span><br><span class="line">			Initial Condition: the linar <span class="keyword">list</span> is alreay existed.</span><br><span class="line">			Operation Result: <span class="keyword">in</span> <span class="keyword">order</span></span><br><span class="line">	&#125; ADT <span class="keyword">List</span></span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-DataStructure(1)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/16/DataStructure(1)/" class="article-date">
  	<time datetime="2015-12-16T02:38:35.000Z" itemprop="datePublished">2015-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/16/DataStructure(1)/">DataStructure(1)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Preface">Preface</h3><p>I will try to use English record my blog from today.</p>
<h3 id="Defination">Defination</h3><p>In computer science,a data structure is a particular way of organizing data in a computer so that it can be used efficiently.Data structures can implement one or more particular abstract data types(ADT),which are the means of specifying the the contract of operations and their complexity. In comparsion,a data structure is a concrete implementation of the contract provided by an ADT.</p>
<p>Different kinds of data structures are suited to different kinds of applications, examples:</p>
<p><li>Databases use B-tree indexes for small percentages of data retrieval.<br></li></p>
<p><li>compilers and databases use dynamic hash tables as look-up tables.<br></li></p>
<p>Usaually, efficient data structures are key to designing efficient algorithms.</p>
<h3 id="Overview">Overview</h3><p>Data structures are generally based on the ability of a computer fetch and store data at any place in its memory, specified by <em>pointer</em>-a bit string, representing a memory address. </p>
<h3 id="Examples">Examples</h3><p>There are numerous types of data structures, gennerally built upon simpler primitive data types:(just like a tress)</p>
<p><li>An array:a number of elements in a specific order, typically all of the same type.I think the array is one of the type we familiar with<br></li></p>
<p><li>An associative array:a more flexible variation on an array, in which name-value pairs can be added and deleted freely. A hash table is a common implementation of an associative array.<br></li></p>
<p><li>A record(also called tuple or struct):an aggregate data structure. A  record is a value that contains oher values, typically in fixed number and sequence and typically indexed by names. The elements of records are usually called fields or members(You can find struct in C, in C++ it have an advanced name class, but it also remmained in C++)<br></li></p>
<p><li>A union: a data structure that specifies which of a number of permitted primitive types may be stored in it’s instances,e.g. float or long integer. Contrast with a record, which could be defined to contain a float and an integer; whereas in a union, ther is only one value at time. Enough space is allocated to contain the widest member datatype(I will give a instance in c)</li></p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">number</span></span></span><br><span class="line">&#123;</span><br><span class="line">int x;</span><br><span class="line">long y;</span><br><span class="line">double z;</span><br><span class="line">&#125;;</span><br><span class="line">number num = (<span class="number">4</span>,<span class="number">15</span>,<span class="number">30.7</span>);</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><li>A tagged union: a variant union contains an additional field indicating its current type, for enhanced type safety.<br></li></p>
<p><li>A set: an abstract data structure that can store specific values, in no particular order and with no duplicate values.<br></li></p>
<p><li>A graph and a tree:linked abstract data structures composed of nodes. Each node contains a value and one or more pointers to other nodes arranged in a hierarchy. Graphs can be used to represent networks, while variants of trees can be used for sorting and searching, having their nodes arranged in some relative order based on their values.<br></li></p>
<p><li>A class: a data structure that contains data fields, like a record, as well as various methods which operate on the contents of the record. In the context of object-oriented programming, records are known as plain old data structures to distinguish them from classes.<br><br></li></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-杂感12.15" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/15/杂感12.15/" class="article-date">
  	<time datetime="2015-12-14T16:38:35.000Z" itemprop="datePublished">2015-12-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/15/杂感12.15/">吐槽</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="我现在很想吐槽">我现在很想吐槽</h3><p>我现在很想吐槽！我现在很想吐槽！我现在很想吐槽！我现在很想吐槽！</p>
<p>没有猫也没有她，自己还多了一堆事。</p>
<p>这事情自己应付了就行。不需要投入太多的精力，自己还是要好好去学习。这事情能获取学校多少帮助就争取获取多少。</p>
<p>听着周杰伦的的《阳光宅男》，自己觉得自己一个唱首《月光男孩》。自己越来越空虚了。好烦！</p>
<p>算了还是好好写代码。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-颓废的两天" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/10/颓废的两天/" class="article-date">
  	<time datetime="2015-12-10T07:38:35.000Z" itemprop="datePublished">2015-12-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/10/颓废的两天/">十二月中旬杂感</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="颓废的两天（12-4）">颓废的两天（12.4）</h3><p>这两天真的很颓废，没有去做什么事情，，Github上面的进度也断了。主要原因是我不应该去看小说啊啊啊。小说真的很能让自己颓废掉。</p>
<p>说下自己未来几天的计划吧</p>
<p><li>1.去看看数字逻辑周六（也就是明天）要去做数字逻辑的实验了<br></li></p>
<p><li>2.还要去复习数据结构和C++，虽然我可以考过这两门，但是太多课没有去上了<br></li></p>
<p><li>3.Osmanthus项目先停一会吧<br></li></p>
<p><li>4.Lua脚本扩展那本书看完，那本书挺基础的<br></li></p>
<h3 id="活过来了（12-10）">活过来了（12.10）</h3><p>终于终于颓废的几天过去了，可以重新好好的做事了，那些奇奇怪怪的事情也都干完了。不过自己还是要注意要考四级了，好好努力咯加油少年</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-雾草！又尼玛是一个难题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/01/雾草！又尼玛是一个难题/" class="article-date">
  	<time datetime="2015-12-01T06:38:35.000Z" itemprop="datePublished">2015-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/01/雾草！又尼玛是一个难题/">Cocos-2dx杂感</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="雾草！又尼玛是一个难题">雾草！又尼玛是一个难题</h3><p>首先还是欢呼一下时间已经进入到十二月份了吧！马上就要结课了，不过这也代表着很快自己就要去考万恶的四级了～雾草，为什么还要考四级啊，郁闷脸。</p>
<p>好吧，说下自己碰到的问题吧＝＝。自己找不到this指向的对象了。首先来看下源代码吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> GameRunning::init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//////////////////////////////</span></span><br><span class="line">    <span class="comment">// 1. super init first</span></span><br><span class="line">    <span class="keyword">if</span> ( !Layer::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> RootNode = CSLoader::createNode(<span class="string">"GameRunning.csb"</span>);</span><br><span class="line">    <span class="keyword">auto</span> GameRunningScene = Scene::create();</span><br><span class="line">    GameRunningScene-&gt;addChild(RootNode);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> GameRunningLayerNode = CSLoader::createNode(<span class="string">"GameRunningLayer.csb"</span>);</span><br><span class="line">    <span class="keyword">auto</span> GameRunningLayer = Layer::create();</span><br><span class="line">    GameRunningLayer-&gt;addChild(GameRunningLayerNode);;</span><br><span class="line">    GameRunningScene-&gt;addChild(GameRunningLayer);</span><br><span class="line">    <span class="keyword">this</span>-&gt;addChild(GameRunningScene);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    CharacterLayer *CharacterLayer = CharacterLayer::create();</span></span><br><span class="line"><span class="comment">//    this-&gt;addChild(CharacterLayer);</span></span><br><span class="line">    <span class="keyword">auto</span> CharacterNode = cocos2d::CSLoader::createNode(<span class="string">"CharacterLayer.csb"</span>);</span><br><span class="line">    <span class="keyword">auto</span> CharacterLayer = Layer::create();</span><br><span class="line">    CharacterLayer-&gt;addChild(CharacterNode);</span><br><span class="line">    <span class="keyword">this</span>-&gt;addChild(CharacterLayer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是自己写的一个程序哈，其中通过<code>this-&gt;addChilde(Character)</code>我们添加了一个CharacterLayer。但是这里的this到底指的是什么呢，我在这里推测这里的this指的应该是layer这样的东西。然后我找到了头文件中的一段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> GameRunning : <span class="keyword">public</span> cocos2d::Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// there's no 'id' in cpp, so we recommend returning the class instance pointer</span></span><br><span class="line">    <span class="keyword">static</span> cocos2d::<span class="function">Scene* <span class="title">createScene</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Here's a difference. Method 'init' in cocos2d-x returns bool, instead of returning 'id' in cocos2d-iphone</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//implement the "static create()" method manually</span></span><br><span class="line">    CREATE_FUNC(GameRunning);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/* defined(____GameRunning__) */</span></span></span><br></pre></td></tr></table></figure>
<p>我们发现在这里面有一个<code>CREATE_FUNC(GameRunning)</code>然后我把它注释了，之后发现游戏画面中通过this添加的图层场景什么鬼的都没有了，于是我推测CREATE_FUNC就是关键。于是我就去查询了CREATE_FUNC()的源码。CREATE_FUNC()是一个宏定义，其定义如下：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @def CREATE_FUNC(__TYPE__)</span><br><span class="line"> * Define a create function for a specific type, such as Layer.</span><br><span class="line"> *</span><br><span class="line"> * @param __TYPE__  class type to add create(), such as Layer.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">#define CREATE_FUNC(__TYPE__) \</span></span><br><span class="line">static __TYPE__* create() <span class="string">\</span></span><br><span class="line">&#123; <span class="string">\</span></span><br><span class="line">    __TYPE__ *pRet = <span class="keyword">new</span>(<span class="attribute">std</span>::nothrow) __TYPE__(); <span class="string">\</span></span><br><span class="line">    <span class="keyword">if</span> (pRet &amp;&amp; pRet-&gt;init()) <span class="string">\</span></span><br><span class="line">    &#123; <span class="string">\</span></span><br><span class="line">        pRet-&gt;autorelease(); <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> pRet; <span class="string">\</span></span><br><span class="line">    &#125; <span class="string">\</span></span><br><span class="line">    <span class="keyword">else</span> <span class="string">\</span></span><br><span class="line">    &#123; <span class="string">\</span></span><br><span class="line">        <span class="keyword">delete</span> pRet; <span class="string">\</span></span><br><span class="line">        pRet = NULL; <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> NULL; <span class="string">\</span></span><br><span class="line">    &#125; <span class="string">\</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看见这是一个创建一个函数给一个详细类，如层。我先闲着无聊，替换下吧好理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> GameRunning* <span class="title">create</span><span class="params">()</span> </span><br><span class="line"></span>&#123; </span><br><span class="line">    GameRunning *pRet = <span class="keyword">new</span>(<span class="built_in">std</span>::nothrow) GameRunning(); </span><br><span class="line">    <span class="keyword">if</span> (pRet &amp;&amp; pRet-&gt;init()) </span><br><span class="line">    &#123; </span><br><span class="line">        pRet-&gt;autorelease(); </span><br><span class="line">        <span class="keyword">return</span> pRet; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">delete</span> pRet; </span><br><span class="line">        pRet = <span class="literal">NULL</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="补充一点小知识点">补充一点小知识点</h3><p><em>今天写代码的时候遇见了很多的C++知识，发现自己都已经忘记了，自己还是回顾下这些C++知识吧</em></p>
<p><li>1.public成员可以通过“.”运算符进行调用。</li></p>
<p><li>2.类中进行赋值会出现非静态成员初始化时的错误。</li></p>
<p><li>3.c++中由于数据与函数封装在一起会出现。</li></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">class</span> Circle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> radius;</span><br><span class="line">	</span><br><span class="line">	Circle() &#123;</span><br><span class="line">		radius = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Circle(<span class="keyword">double</span> newRadius) &#123;</span><br><span class="line">		radius = newRadius;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> radius * radius * <span class="number">3.14</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以直接使用getArea()方法而不去添加参数。</p>
<p><li>4.类的构造函数不能够有返回值。</li></p>
<p><li>5.对象指针什么鬼的：</li></p>
<p>定义：指向类的成员的指针。在C++中，可以说明指向类的数据成员和成员函数的指针。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 张仲昊
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>