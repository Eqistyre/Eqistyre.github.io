<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SakuraNeko</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="SakuraNeko">
<meta property="og:url" content="http://eqistyre.github.io/index.html">
<meta property="og:site_name" content="SakuraNeko">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SakuraNeko">
<meta name="twitter:description">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://raw.githubusercontent.com/AirOil/Test_X/master/imgs/IMG_0230.PNG" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">张仲昊</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Eqistyre" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.talisk.cn">talisk斯温</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">人间二十年,花鸟风月</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">张仲昊</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://raw.githubusercontent.com/AirOil/Test_X/master/imgs/IMG_0230.PNG" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">张仲昊</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Eqistyre" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-刷codewars的小记录" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/28/刷codewars的小记录/" class="article-date">
  	<time datetime="2016-01-28T07:38:35.000Z" itemprop="datePublished">2016-01-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/28/刷codewars的小记录/">CodeWars[1]</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="记录">记录</h3><p>今天在CodeWars上面刷题，发现第一题就不会做。纯英语看的我慎得慌。</p>
<p>map() 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="function"><span class="title">map</span><span class="params">(callback[, thisArg])</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function fuzzyPlural(single) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="literal">result</span> = single.replace(/o/g, 'e');  </span><br><span class="line">  <span class="keyword">if</span>( single === 'kangaroo')&#123;</span><br><span class="line">    <span class="literal">result</span> += 'se';</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> words = [<span class="string">"foot"</span>, <span class="string">"goose"</span>, <span class="string">"moose"</span>, <span class="string">"kangaroo"</span>];</span><br><span class="line">console.log(words.map(fuzzyPlural));</span><br><span class="line"></span><br><span class="line">// [<span class="string">"feet"</span>, <span class="string">"geese"</span>, <span class="string">"meese"</span>, <span class="string">"kangareese"</span>]</span><br></pre></td></tr></table></figure>
<p>也就是说，map里面写回调方法。然后可以执行，题目的意思并不是让你重新去写一个，我蒙逼了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> lengthOfSequence</span> = function (arr, n) &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Write some scripts here</span></span><br><span class="line">  <span class="variable"><span class="keyword">var</span> index1</span> = arr.indexOf(n);</span><br><span class="line">  <span class="variable"><span class="keyword">var</span> index2</span> = arr.indexOf(n,index1 + <span class="number">1</span>);</span><br><span class="line">  <span class="variable"><span class="keyword">var</span> index3</span> = arr.indexOf(n,index2 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (index1 == -<span class="number">1</span> || index2 == -<span class="number">1</span> || index3 != -<span class="number">1</span>) &#123;<span class="keyword">return</span> <span class="number">0</span>&#125; ;</span><br><span class="line">  <span class="keyword">return</span> index2 - index1 + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一种机智的方法！</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listToArray</span><span class="params">(list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">array</span> = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> node = <span class="keyword">list</span>; node; node = node.next)</span><br><span class="line">    <span class="keyword">array</span>.push(node.value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是6</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pattern</span><span class="params">(n)</span> <span class="comment">&#123;</span><br><span class="line">  var res = [], i;</span><br><span class="line">  for(i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">    res.push(Array(i + 1).join(i));</span><br><span class="line">  &#125;</span></span><br><span class="line">  <span class="title">return</span> <span class="title">res</span>.<span class="title">join</span><span class="params">(<span class="string">'\n'</span>)</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有这种拼接方式我都忘了。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">maskify</span><span class="params">(cc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cc.slice(<span class="number">0</span>, -<span class="number">4</span>).replace(/./g, <span class="string">'#'</span>) + cc.slice(-<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又是正则。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function insertDash(num) &#123;</span><br><span class="line">   return num.toString().replace(/[<span class="link_label">13579</span>](<span class="link_url">?=[13579]</span>)/g, "$&amp;-");</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我想今天刷到6kyu。也许我也该用Ruby写下这些东西。</p>
<p>6kyu的第一题。＝＝。并不会做啊！！题目如下：</p>
<p>You probably know the “like” system from Facebook and other pages. People can “like” blog posts, pictures or other items. We want to create the text that should be displayed next to such an item.</p>
<p>Implement a function <code>likes :: [String] -&gt; String</code>, which must take in input array, containing the names of people who like an item. It must return the display text as shown in the examples:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">likes</span> [] // must <span class="keyword">be </span><span class="string">"no one likes this"</span></span><br><span class="line"><span class="label">likes</span> [<span class="string">"Peter"</span>] // must <span class="keyword">be </span><span class="string">"Peter likes this"</span></span><br><span class="line"><span class="label">likes</span> [<span class="string">"Jacob"</span>, <span class="string">"Alex"</span>] // must <span class="keyword">be </span><span class="string">"Jacob and Alex like this"</span></span><br><span class="line"><span class="label">likes</span> [<span class="string">"Max"</span>, <span class="string">"John"</span>, <span class="string">"Mark"</span>] // must <span class="keyword">be </span><span class="string">"Max, John and Mark like this"</span></span><br><span class="line"><span class="label">likes</span> [<span class="string">"Alex"</span>, <span class="string">"Jacob"</span>, <span class="string">"Mark"</span>, <span class="string">"Max"</span>] // must <span class="keyword">be </span><span class="string">"Alex, Jacob and 2 others like this"</span></span><br></pre></td></tr></table></figure>
<p>解答如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">likes</span><span class="params">(names)</span> </span>&#123;</span><br><span class="line">  names = names || [];</span><br><span class="line">  <span class="keyword">switch</span>(names.length)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="string">'no one likes this'</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> names[<span class="number">0</span>] + <span class="string">' likes this'</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> names[<span class="number">0</span>] + <span class="string">' and '</span> + names[<span class="number">1</span>] + <span class="string">' like this'</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> names[<span class="number">0</span>] + <span class="string">', '</span> + names[<span class="number">1</span>] + <span class="string">' and '</span> + names[<span class="number">2</span>] + <span class="string">' like this'</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> names[<span class="number">0</span>] + <span class="string">', '</span> + names[<span class="number">1</span>] + <span class="string">' and '</span> + (names.length - <span class="number">2</span>) + <span class="string">' others like this'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有下面这个简直clever到极致的方法！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">likes</span> (<span class="params">names</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> templates = [</span><br><span class="line">    <span class="string">'no one likes this'</span>,</span><br><span class="line">    <span class="string">'&#123;name&#125; likes this'</span>,</span><br><span class="line">    <span class="string">'&#123;name&#125; and &#123;name&#125; like this'</span>,</span><br><span class="line">    <span class="string">'&#123;name&#125;, &#123;name&#125; and &#123;name&#125; like this'</span>,</span><br><span class="line">    <span class="string">'&#123;name&#125;, &#123;name&#125; and &#123;n&#125; others like this'</span></span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">var</span> idx = <span class="built_in">Math</span>.min(names.length, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> templates[idx].replace(<span class="regexp">/&#123;name&#125;|&#123;n&#125;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val === <span class="string">'&#123;name&#125;'</span> ? names.shift() : names.length;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateHypotenuse</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>) || (<span class="keyword">typeof</span> a != <span class="string">"number"</span> || <span class="keyword">typeof</span> b != <span class="string">"number"</span> ) || (<span class="built_in">isNaN</span>(a) || <span class="built_in">isNaN</span>(b))) &#123;</span><br><span class="line">  	<span class="keyword">return</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(a*a + b*b).toFixed(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toFixed()精度控制，typeof 检测类型，但是检测不出NaN,isNan()用于检测NaN。</p>
<p>题目：<br>The main idea is to count all the occuring characters(UTF-8) in string. If you have string like this aba then the result should be { ‘a’: 2, ‘b’: 1 }</p>
<p>What if the string is empty ? Then the result should be empty object literal { }</p>
<p>解法：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">count</span> (string) &#123;  </span><br><span class="line">  var <span class="built_in">count</span> = &#123;&#125;;</span><br><span class="line">  string.split(<span class="string">''</span>).forEach(<span class="function"><span class="keyword">function</span><span class="params">(s)</span></span> &#123;</span><br><span class="line">     <span class="built_in">count</span>[s] ? <span class="built_in">count</span>[s]++ : <span class="built_in">count</span>[s] = <span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-开发日志(三)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/25/开发日志(三)/" class="article-date">
  	<time datetime="2016-01-25T01:38:35.000Z" itemprop="datePublished">2016-01-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/25/开发日志(三)/">开发日志（三）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>回家了，在家休息了好几天＝＝。准备用echarts捏一个数据可视化的东西。游戏的话，设计最近没有交原型给我呢。</p>
<h4 id="Echarts-ccnu"><li>Echarts-ccnu</li></h4><p>1.23<table><br>大晚上的发现会有跨域请求限制，cors在我这边解决不了，只能放弃原有方案，重新使用Express建立一个服务器后台。</table></p>
<p>1.24<table><br>下了一堆的Atom插件。</table></p>
<p>1.25~9:00<table><br>开始进行后台搭建，node什么的好多都忘了。</table></p>
<p>1.25~11:00<table><br>重新看了一下许多的node方面的内容，路由控制，rest一类的。</table></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-开发日志(二)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/19/开发日志(二)/" class="article-date">
  	<time datetime="2016-01-19T01:38:35.000Z" itemprop="datePublished">2016-01-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/19/开发日志(二)/">开发日志（二）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>家里要下雪了，所以改签了车票，二十号回家，自己也有点想家了。</p>
<h4 id="Zyklus-Green"><li>Zyklus-Green</li></h4><p>1.19~09:00<table>泡了碗面，把给的图重新切了一下。其实滑动条是有的，不需要自己重做，自己把它稍微重写下吧。</table></p>
<p>1.19~11:30<table>把settingLayer写好了，滑动条属性get。准备设置触碰范围。</table></p>
<p>1.19~16:15<table>无线滚动做好，着手于其余的细微调节。</table></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-开发日志(一)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/18/开发日志(一)/" class="article-date">
  	<time datetime="2016-01-18T07:38:35.000Z" itemprop="datePublished">2016-01-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/18/开发日志(一)/">开发日志（一）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>自己还是得写开发日志呀，也可以作为写代码时的消遣＝＝。前几天的开发进度只能模模糊糊的写上去了。</p>
<h4 id="Zyklus-Green"><li>Zyklus-Green</li></h4><p>1.16<table>项目正式开工，调好了分辨率。</table></p>
<p>1.17<table>加入了启动界面，音乐控制。中途由于自己傻，少写了一个导演类，导致无法获取实例。</table></p>
<p>1.18~11:30<table>又出Bug了，游戏场景无法变化图片。</table></p>
<p>1.18~15:34<table>发现imageview类竟然是ui类的子类，所以选择在计时器中使用，但发现Fps逐渐降低，猜测是由于不断执行setvisible操作所致，修复中。</table></p>
<p>1.18~16:34<table>整整一个小时，终于修好了这个Bug,只要把声明重新写在public里就行了，然后再分别定义分别判断，正在加入第二张图，构建无限循环。</table></p>
<p>1.18~16:59<table>图给错了！！这图压根不能无限循环好吧，明天需要重做这图。</table></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Vue_js概述" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/13/Vue_js概述/" class="article-date">
  	<time datetime="2016-01-13T07:38:35.000Z" itemprop="datePublished">2016-01-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/13/Vue_js概述/">Vue.js概述以及一些吐槽</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是vue">什么是vue</h3><p>自我感觉，读完文档后感觉Vue是一种MVVM模式的图形界面框架拥有着低耦合的优点。自己不是太精通Javascript，就谈谈一些感想吧。Vue中可以对元素进行快速选取操作，以及动态命名。实现无需后台数据传入直接计算的功能。例如我们可以：</p>
<p>HTML</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = <span class="string">"examples"</span>&gt;</span><br><span class="line">  <span class="expansion">&#123;&#123;message&#125;&#125;</span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>Javascript</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">var</span> vm = new vue(&#123;</span><br><span class="line">  el: <span class="string">"#examples"</span></span><br><span class="line">  <span class="typedef"><span class="keyword">data</span>: <span class="container">&#123;</span><br><span class="line">    <span class="title">message</span>: "<span class="type">Sakura</span>"</span><br><span class="line">  &#125;</span></span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样之后就会发生动态变换了。</p>
<h3 id="优点">优点</h3><p><li>Vue 是一种视图层的开发框架，这也决定了它不必像Angular那样构造一个单面应用，可以很好的镶入已有的页面中，并且很好的配合其它框架使用。</li></p>
<p><li>默认单向绑定，同时也支持双向绑定，可以有效防止数据逆流。</li></p>
<h3 id="吐槽">吐槽</h3><p>没想到竟然趴在桌子上就睡着了呢，放假的学校总是冷冷清清的。下午要得好好写代码呢。准备用vue写一个小的追番应用</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-NodeExpress" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/13/NodeExpress/" class="article-date">
  	<time datetime="2016-01-13T07:38:35.000Z" itemprop="datePublished">2016-01-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/13/NodeExpress/">express概述</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言">前言</h3><p>上火车了，时间真的好快，终于快回家了，列车上也没有什么事情，也就把express看一下吧。</p>
<p>express 是一种使用广泛的基于node的开发框架，它具有着许多的优点。</p>
<p><li>路由控制</li></p>
<p><li>模板解析支持</li></p>
<p><li>动态视图</li></p>
<p><li>用户会话</li></p>
<p><li>CSRF保护</li></p>
<p><li>静态文件服务</li></p>
<p><li>错误控制器</li></p>
<p><li>访问日志</li></p>
<p><li>缓存</li></p>
<p><li>插件支持</li></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-swift&lt;二&gt;" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/13/swift<二>/" class="article-date">
  	<time datetime="2016-01-12T17:38:35.000Z" itemprop="datePublished">2016-01-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/13/swift<二>/">Swift学记笔记（二）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="空合运算符(Nil_Coalescing_Operator)">空合运算符(Nil Coalescing Operator)</h3><p>空合运算符（a ?? b）将对可选类型a进行空判断，如果a包含一个值进行解封，否则就返回一个默认值b,这个运算符有两个条件：</p>
<p><li>表达式a必须式Optional类型</li></p>
<p><li>默认值b的类型必须要和a储存值的类型保持一致</li></p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function_or_atom">a</span> <span class="exclamation_mark">!</span>= <span class="function_or_atom">nil</span> ? <span class="function_or_atom">a</span> <span class="exclamation_mark">!</span> : <span class="function_or_atom">b</span></span><br></pre></td></tr></table></figure>
<p>上述代码使用了三目运算符。当可选类型a的值不为空时，进行强制解封(a!)访问a中的值，反之当a中的值为空时，返回默认值b。无疑空合运算符(??)提供了一种更为优雅的方式去封装条件判断和解封两种行为，显得简洁以及更具有可读性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName = <span class="string">"red"</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="built_in">String</span>? <span class="comment">//默认为nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse = userDefinedColorName ?? defaultColorName ?? defaultColorName</span><br></pre></td></tr></table></figure>
<p>userDefinedColorName变量被定义为一个可选的String类型，默认值为nil。由于userDefinedColorName是一个可选类型，我们可以使用空合运算符去判断其值。在上一个例子中，通过空合运算符为一个名为colorNameToUse的变量赋予一个字符串类型初始值。由于userDefinedColorName值为空，因此表达式userDefinedColorName ?? defaultColorName返回defaultColorName的值，即red。</p>
<p>另一种情况，分配一个非空值（non-nil）给userDefinedColorName,再次执行空合运算，运算结果为封包在userDefaultColorName中的值，而非默认值。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">user</span>DefaultColorName = <span class="string">"green"</span></span><br><span class="line">colorNameToUse = <span class="keyword">user</span>DefinedColorName ?? <span class="keyword">default</span>ColorName</span><br></pre></td></tr></table></figure>
<h3 id="区间运算符">区间运算符</h3><p>Swift提供了两个方便表达一个区间的运算符。</p>
<h3 id="闭区间运算符">闭区间运算符</h3><p>闭区间运算符（a…b）定义一个包含从a到b（包括a和b）的所有值的区间，b必须大于等于a。闭区间运算符在迭代一个区间的所有值时是非常有用的（Ps：这个与python的语法好像啊）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">\(index)</span> * 5 = <span class="subst">\(index * <span class="number">5</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 * 5 = 5</span></span><br><span class="line"><span class="comment">// 2 * 5 = 10</span></span><br><span class="line"><span class="comment">// 3 * 5 = 15</span></span><br><span class="line"><span class="comment">// 4 * 5 = 20</span></span><br><span class="line"><span class="comment">// 5 * 5 = 25</span></span><br></pre></td></tr></table></figure>
<p>半开区间运算符<br>(a..&lt;b)从a到b不包括b的区间。</p>
<h3 id="集合（Sets）">集合（Sets）</h3><p>Swift语言中的Arrarys,Sets或Dictionaries中储存的数据值类型必须明确。这意味着我们不能把不正确的数据类型插入其中。同时也说明我们完全可以对取回值的类型非常自信。</p>
<blockquote>
<p>注意：<br>Swift的Arrays,Sets和Dictionaries类型被实现为泛型集合。</p>
</blockquote>
<h3 id="集合的可变性">集合的可变性</h3><p>如果创建一个Arrays,Sets或Dictonaries并且把它们分配成一个变量，这个集合将会是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项，或者改变集合中的数据项。如果我们把Arrarys,Sets或Dictionaries分配成常量，那么它就是不可变的，它的大小与内容都不能被改变。</p>
<h3 id="集合类型的语法">集合类型的语法</h3><p>Swift中的Set类型被写为Set<element>，这里的Element表示Set中允许储存的类型，和数组不同的是，集合没有等价的简化形式。</element></p>
<p><li>创建和构造一个空的集合</li></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters = <span class="built_in">Set</span>&lt;characters&gt;()</span><br></pre></td></tr></table></figure>
<p>此外，如果上下文提供了类型信息，比如作为函数或者已知类型的变量或常量，我们可以通过一个空的数组字面量创建一个空的Set：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letters.<span class="function"><span class="title">insert</span><span class="params">(<span class="string">"a"</span>)</span></span></span><br><span class="line"><span class="comment">//letters 现在含有一个character类型的值</span></span><br><span class="line">letter = []</span><br><span class="line"><span class="comment">//letters 现在是一个空的Set,但是它依然是Set&lt;character&gt;类型</span></span><br></pre></td></tr></table></figure>
<p><li>用数组字面量创建集合</li></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGames: <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>,  <span class="string">"Hip hop"</span>]</span><br></pre></td></tr></table></figure>
<p><li>操作</li></p>
<p>集合的很多操作我们都可以使用数组进行类比，我们来说一些一些特殊的操作吧。</p>
<p>基本的集合操作</p>
<blockquote>
<p>a.intersect(b) 交<br>a.exclusiveOr(b) 异或<br>a.union(b) 并<br>a.subtract(b) a-b</p>
</blockquote>
<p>集合成员关系和相等</p>
<blockquote>
<p>== 来判断两个集合是否包含全部相同的值<br>isSubsetOf(_:) 判断一个集合中的值是否也被包含在另外一个集合中。<br>isSupersetOf(_:) 判断一个集合中包含另一个集合中所有的值。<br>isStrictSubsetOf(_:) 判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。<br>isDisjointWith(_:) 判断两个集合是否不含有相同的值</p>
</blockquote>
<h3 id="数组">数组</h3><p>数组的简单语法</p>
<p>写Swift数组应该遵循像Array<element>这样的形式，其中Element是这个数组中唯一允许存在的数据类型。我们也可以使用像[Element]这样的简单语法。尽管两种形式在功能上是一样的，但是推荐较短的那种。</element></p>
<p>创建一个空数组</p>
<p>我们可以使用构造函数语法来创建一个由特定数据类型构成的空数组：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var someInts = [<span class="link_label">Int</span>](<span class="link_url"></span>)</span><br><span class="line">print("someInts is of type [Int] with \(someInts.count) items.")</span><br><span class="line">//打印“someInts is of type [Int] with 0 items.”</span><br></pre></td></tr></table></figure>
<p>注意，通过构造函数的类型，someInts的值类型被推断为[Int]。</p>
<p>或者，如果代码上下文中已经提供了类型信息，例如体格函数参数或者一个已经定义好了的常量或者变量，我们可以使用空数组语句创建一个空数组，它的写法很简单：[]（一对方括号）：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">someInts.<span class="function"><span class="title">append</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="comment">// someInts 现在包含一个Int值</span></span><br><span class="line">someInts = []</span><br><span class="line"><span class="comment">// 现在是空数组了，但仍然是[Int]类型。</span></span><br></pre></td></tr></table></figure>
<p>创建一个带有默认值的数组</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var threeDoubles = [<span class="link_label">Double</span>](<span class="link_url">count: 3, repeatValue:0.0</span>)</span><br><span class="line">//threeDoubles是一种[Double]数组，等价于[0.0, 0.0, 0.0]</span><br></pre></td></tr></table></figure>
<p>通过两个数组相加创建一个数组</p>
<p>我们可以使用加法操作符(+)来进行拼接操作：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> anotherThreeDoubles = <span class="function"><span class="title">Array</span><span class="params">(count: <span class="number">3</span>, repeatedValue: <span class="number">2.5</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">var</span> sixDoubles = threeDoubles + anotherThreeDoubles</span><br><span class="line"><span class="comment">//[0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span></span><br></pre></td></tr></table></figure>
<h3 id="访问和修改数组">访问和修改数组</h3><blockquote>
<p>count 可以用于获取数组中的数据项数量：        eg: shoppingList.count<br>isEmpty 作为检查 count属性的值是否为0的捷径：         eg:shoppingList.isEmpty</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> shoppingList.isEmpty &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"The shopping list is empty."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"The shopping list is not empty."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>append(_:) 可以在数组后面添加新的数据项：<br>insert(_:atIndex:) 向某个具体索引值之前添加数据项        eg:shoppingList.insert(“Mapple Syrup”, atIndex: 0)<br>removeAtIndex(_:) 移除数组中某一项。这个方法把数组在特定索引值中储存的数据项移除并且返回被移除的数据项（我们不需要的时候可以无视）：</p>
</blockquote>
<h3 id="字典">字典</h3><p>字典是一种储存多个相同类型的容器。每个值（value）都关联唯一的键（key）。</p>
<blockquote>
<p>注意：<br>Swift 的Dictionary类型被桥接到Foundation的NSDictionary类。<br>更多关于在Foundation和Cocoa中使用Dictionary类型的信息，参见 Using Swift with Cocoa and Objective-C (Swift 2.1) 一书。</p>
</blockquote>
<p><li>字典的快捷语法</li></p>
<p>使用Dictionary<key, value="">定义字典，我们也可以用[key: Value]这样的快捷形式创建，并且这种方法会更好。</key,></p>
<p><li>创建一个空字典</li></p>
<p>我们可以像数组一样使用构造语法创建一个拥有确定类型的空字典：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var namesOfIntegers = [<span class="link_label">Int: String</span>](<span class="link_url"></span>)</span><br><span class="line">// namesOfIntergers是一个空的[Int: String] 字典</span><br></pre></td></tr></table></figure>
<p>这个例子创建一个[Int: String]类型的空字典来储存整数的英语命名。它们键是Int型，值是String型。</p>
<p><li>访问和修改字典</li></p>
<p>我们也可以通过字典的方法和属性来访问和修改字典，或者通过使用下标语法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C++知识点maybe" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/02/C++知识点maybe/" class="article-date">
  	<time datetime="2016-01-01T16:38:35.000Z" itemprop="datePublished">2016-01-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/02/C++知识点maybe/">考试之前看的各种c++知识点</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="内联函数">内联函数</h3><p>1.使用inline的一些注意事项</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;<span class="comment">//inline 仅与声明放在一起</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码不能成为内联函数，以下可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="comment">//函数与定义放在了一起</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以说，inline是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。比较好的风格就是只在定义前面加上inline,而不是在声明和定义前面都加。这样才能体现出c++/c的一种良好设计风格声明与定义不可混为一谈。</p>
<h3 id="拷贝构造函数">拷贝构造函数</h3><p>拷贝构造函数，又称为复制构造函数，是一种特殊的构造函数，它由编译器调用来完成一些基于同一类的其它对象的构建及其初始化。其唯一的形参必须是引用，但是并不限制为const，一般普遍的会加上const限制。此函数经常用在函数调用时用户定义类型的值传递及返回。拷贝构造函数要调用基类的拷贝构造函数和成员函数。如果可以的话，它将用常量方式调用，另外，也可以用非常量方式调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> CExample &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  CExample(<span class="keyword">int</span> b) &#123;</span><br><span class="line">    a = b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一般函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">  CExample B = A;</span><br><span class="line">  B.Show();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，屏幕输出100。从以上代码可以看出，系统为对象A的复制过程。就对象而言，相同类型的类对象是通过拷贝构造函数来完成整个复制过程的。</p>
<p>下面举例说明拷贝构造函数的工作过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> CExample &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  CExample(<span class="keyword">int</span> b) &#123;</span><br><span class="line">    a = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//拷贝构造函数</span></span><br><span class="line">  CExample(<span class="keyword">const</span> CExample&amp; C) &#123;</span><br><span class="line">    a = C.a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//一般函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">  CExample B = A;<span class="comment">//CExample B(A)；具有相同的效果</span></span><br><span class="line">  B.Show();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数模版">函数模版</h3><p>在创建完成抽象操作的函数时，如：拷贝，反转和排序，你必须定义多个版本以便能处理每一种数据类型。以max()函数为例，它返回两个参数中的较大者：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> <span class="built_in">max</span>(<span class="keyword">double</span> first, <span class="keyword">double</span> <span class="built_in">second</span>);</span><br><span class="line">complex <span class="built_in">max</span>(complex first, <span class="keyword">double</span> <span class="built_in">second</span>);</span><br><span class="line">date <span class="built_in">max</span>(date first, date <span class="built_in">second</span>);</span><br></pre></td></tr></table></figure>
<p>尽管这个函数针对不同的数据类型其实现都是一样的，但程序员必须为每一种数据类型定义一个单独的版本：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">double max(double <span class="keyword">first</span>, double <span class="keyword">second</span>) &#123;</span><br><span class="line"><span class="command">  return</span> <span class="keyword">first</span> &gt; <span class="keyword">second</span>? <span class="keyword">first</span> : <span class="keyword">second</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex max(complex <span class="keyword">first</span>, complex <span class="keyword">second</span>) &#123;</span><br><span class="line"><span class="command">  return</span> <span class="keyword">first</span> &gt; <span class="keyword">second</span>? <span class="keyword">first</span> : <span class="keyword">second</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">date</span> max(<span class="type">date</span> <span class="keyword">first</span>, <span class="type">date</span> <span class="keyword">second</span>) &#123;</span><br><span class="line"><span class="command">  return</span> <span class="keyword">first</span> &gt; <span class="keyword">second</span>? <span class="keyword">first</span> : <span class="keyword">second</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样不仅仅会重复劳动，容易出错，而且还带来很大的维护和调试工作量。更糟的是，即使你在程序中不使用某个版本，其代码仍然增加可执行文件的大小，大多数编译器将不会从可执行文件中删除引用的函数。</p>
<p>所以我们使用了函数模版这种方法解决这个问题。</p>
<p>第一步：定义<br><br>函数模版里的声明是关键字template后跟随一个或多个模版在尖括弧内的参数和原型。与普通函数相对，它通常是在一个转换单元里声明，而在另一个单元中定义，你可以在某个头文件中定义模版。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> MAX_INCLUDED</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_INCLUDED</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T t1, T t2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (t1 &gt; t2) ? t1:t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>定义T作为模版参数，或者是占位符，当实例化max()时，它将替代具体的数据类型。max是函数名，t1和t2是其参数，返回值的类型为T。你可以像使用普通的函数那样使用这个max()。编译器按照所使用的数据类型自动产生相应的模版转化，或者说是实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>, m = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> highest = max(n, m);<span class="comment">//产生int版本</span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">complex</span> c1,c2;</span><br><span class="line"><span class="comment">//..给c1, c2赋值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">complex</span> higher = max(c1,c2);<span class="comment">//complex 版本</span></span><br></pre></td></tr></table></figure>
<p>第二步：改进设计<br><br>上述的max()的实现还有些土气——参数t1和t2是用值来传递的。对于像int,float这样的内建数据类型来说不是什么问题。但是，对于像std::complex 和 std::string 这样的用户定义的数据类型来说，通过引用传递参数会更有效。此外，因为max()会认为其参数是不会被改变的，我们应该将t1和t2声明为变量const(常量)。下面是max()的改进版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(<span class="keyword">const</span> T&amp; t1, <span class="keyword">const</span> T&amp; t2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>(t1 &gt; t2) ? t1 : t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类">抽象类</h3><p>在C++中，含有纯虚拟函数的类称为抽象类，它不能生成对象，即抽象类无法创建对象。<br><br>纯序函数的形式如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualreturntypefunction()=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>例如，类A有两个纯虚函数lock()、unlock()和一个虚析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  virtualvoidlock(<span class="keyword">void</span>)=<span class="number">0</span>;</span><br><span class="line">  virtualvoidunlock(<span class="keyword">void</span>)=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span>~A(<span class="keyword">void</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类模版与_STL_编程">类模版与 STL 编程</h3><p><li>类模版的概念:<br><br>类模版定义的语法为</li></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;模版参数表&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">	成员名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中模版参数表中的类型为参数化类型，也称可变类型，类型名为class(或typename);模版参数表中的类型也可包含普通类型，普通类型的参数用来为类的成员提供初值。类模版中的成员函数可以是模版函数，也可以是普通函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> TNO, <span class="keyword">class</span> TScore, <span class="keyword">int</span> num&gt;       <span class="comment">//TNO, TScore 为参数化类型</span></span><br><span class="line"><span class="keyword">class</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  TNO StudentID[num];       <span class="comment">//参数化类型数组，储存姓名</span></span><br><span class="line">  TScore score[num];        <span class="comment">//参数化类型数组，储存分数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TNO <span class="title">TopStudent</span><span class="params">()</span> </span>&#123;        <span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">return</span> StudentID[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">BelowNum</span><span class="params">(TScore ascore)</span> </span>&#123;       <span class="comment">//函数模版</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;       <span class="comment">//普通函数</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="虚基类">虚基类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名 : <span class="typename">virtual 继承方式 基类名</span></span></span><br></pre></td></tr></table></figure>
<p><li>virtual 是关键字，声明该变量为派生类的虚基类。</li></p>
<p><li>在多继承的情况下，虚基类关键字的作用范围和继承方式关键字相同，只对紧跟其后面的基类起作用。</li></p>
<p><li>声明了虚基类之后，虚基类在进一步派生的过程中始终和派生类一起，维护同一个基类对象的拷贝。</li></p>
<h3 id="容器">容器</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-DataStructure(5)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/25/DataStructure(5)/" class="article-date">
  	<time datetime="2015-12-25T14:40:35.000Z" itemprop="datePublished">2015-12-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/25/DataStructure(5)/">DataStructure(5)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="平衡二叉树">平衡二叉树</h3><p>“平衡因子（Balance Factor, 简BF）”：BF(T) = h<sub>L</sub> - h<sub>R</sub>。<br><br>平衡二叉树(Balanced Binary Tree) (AVL树)：空树，或者任一结点左、右子树高度差的绝对值不超过1，即|BF(T)| ≤ 1。</p>
<h3 id="平衡二叉树的调整">平衡二叉树的调整</h3><p><img src="https://raw.githubusercontent.com/AirOil/Test_X/bf0bff39b0ea74be9ad67b971c1062e0091483c9/imgs/二叉树.png" alt="二叉树的调整"></p>
<p>这个放图了，不放图的话实在是说不清楚，哈哈～<br><br>也就是说由于插入了一个元素，我们或许会导致这个二叉树不再平衡。所以我们得对这个二叉树进行调整。</p>
<h3 id="图(map)">图(map)</h3><p>图的定义：</p>
<p>表示“多对多”的关系<br><br>包含</p>
<p><li>一组顶点：通常用V(Vertex)表示顶点集合</li></p>
<p><li>一组边：通常用E(Edge)表示边的集合</li></p>
<p><li>边是顶点对：(v, w) ∈ E, 其中v, w ∈ V</li></p>
<p><li>有向边\<v, w\="">表示从v指向w的边（单行线）</v,></li></p>
<p><li>不考虑重边与自回路</li></p>
<p>抽象数据类型定义</p>
<p><li>类型名称：图(Graph)</li></p>
<p><li>数据对象集：G(V, E)由一个非空的有限顶点集合V和一个有限边集合E组成。</li></p>
<p><li>操作集：对于任意图G ∈ Graph， 以及v ∈,  e ∈ E</li></p>
<p>操作方法：</p>
<p><li>Graph Create(): 建立并返回空图；</li></p>
<p><li>Graph InsertVertex(Graph G, Vertex v):将v插入G；</li></p>
<p><li>Graph InsertEdge(Graph G, Edge e):将e插入G；</li></p>
<p><li>void DFS(Graph G, Vertex v):从顶点v出发深度优先遍历图G；</li></p>
<p><li>void DFS(Graph G, Vertex v):从顶点v出发宽度优先遍历图G；</li></p>
<p><li>void ShortestPath(Graph G, Vertex v, int Dist[]):计算图G中顶点v到任意其他顶点的最短距离；</li></p>
<p><li>void MST(Graph G):计算图G的最小生成树；</li></p>
<p><li>………</li></p>
<p>常见术语：</p>
<p><li>无向图：所有的图都没有方向</li></p>
<p>怎么在程序中表示一个图：</p>
<p><li>1.邻接矩阵G[N][N]–N个顶点从0到N-1编号。<br><br>特征:对角线上全是0；<br><br>特征:按对角线对称；</li></p>
<blockquote>
<p>G[i][j] = 1(若\<v<sub>i,v<sub>j</sub>>) or 0(否则)</v<sub></p>
</blockquote>
<p>Question：对于有N个顶点的无向图，怎样存储可以省一半空间？<br><br>Answer:用一个长度为N(N+1)/2的1维数组</p>
<p><li>2.<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-SICP(1)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/22/SICP(1)/" class="article-date">
  	<time datetime="2015-12-22T14:40:35.000Z" itemprop="datePublished">2015-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/22/SICP(1)/">SICP读书笔记(1)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言(Preface)">前言(Preface)</h3><p>我又开坑了，我要成为一代坑王了，对这个坑的期望是，一天一小节，这个好像还是挺有难度的＝＝。哦对，寒假的话还要把以前的坑给填完＝＝。事情好多呀！～。</p>
<h2 id="第一章_构造过程抽象">第一章 构造过程抽象</h2><h3 id="程序设计的基本元素">程序设计的基本元素</h3><p>一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该成为一种框架，使我们能够在其中组织自己的有关计算过程的思想。这样，当我们描述一个语言时，就需要将注意力特别放在这一语言所提供的，能够将简单的认识组合起来形成更复杂认识的方法方面。每一种强有力的语言都为此提供了三种机制：</p>
<p><li>基本表达形式：用于表示语言所关心的所关心的最简单的个体。</li></p>
<p><li>组合的方法：通过它们可以从较简单的东西出发构造出复合的元素。</li></p>
<p><li>抽象的方法：通过它们可以为复合对象命名，并将它们当作单元去操作。</li></p>
<h3 id="过程与它们所产生的计算">过程与它们所产生的计算</h3><h4 id="线性的递归和迭代">线性的递归和迭代</h4><p>首先考虑由下面表达式定义的阶乘函数：</p>
<p>n! = n <em> (n-1) </em> (n-2) <em> … </em> 3 <em> 2 </em> 1</p>
<p>计算阶乘的方式有许多种，其中有一种是利用一下的认识：对于一个正整数n, n!就等于n * (n - 1)!, 然后我们就可以直接翻译成下面过程：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">factorial</span> n)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">=</span></span> n <span class="number">1</span>)</span></span><br><span class="line">			<span class="number">1</span></span><br><span class="line">			<span class="list">( * <span class="list">(<span class="keyword">factorial</span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> n <span class="number">1</span>)</span>)</span>)</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>现在让我们采用另一种不同的观点来计算阶乘。我们可以将阶乘n!的规则描述为：先乘起1和2，而后将得到的结果乘以4，这样下去直到n。更形式的说，我们要维持一个变动中的乘积product，以及一个从1到n的计数器，这一计算过程描述为counter和product的如下变化，从第一步到下一步，它们都按照下面规则改变：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">product</span> &lt;- counter * product</span><br><span class="line"><span class="title">couter</span> &lt;- counter + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到，n!也就是计数器counter超过乘积product的值。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(define (factorial n))</span><br><span class="line">	(fact-iter <span class="number">1</span> <span class="number">1</span> n)</span><br><span class="line"></span><br><span class="line">(define (factorial-iter <span class="built_in">product</span> counter <span class="built_in">max</span>-<span class="built_in">count</span>))</span><br><span class="line">	(<span class="keyword">if</span> (&gt; counter <span class="built_in">max</span>-<span class="built_in">count</span>))</span><br><span class="line">		<span class="built_in">product</span></span><br><span class="line">		(fact-iter (* counter <span class="built_in">product</span>))</span><br><span class="line">					(+ counter <span class="number">1</span>)</span><br><span class="line">					 <span class="built_in">max</span>-<span class="built_in">count</span>)))</span><br></pre></td></tr></table></figure>
<p>与前面一样，我们也可以应用替换模型来查看6!的计算过程！！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(factorial <span class="number">6</span>)</span><br><span class="line">(fact-oter <span class="number">1</span> <span class="number">1</span> <span class="number">6</span>)</span><br><span class="line">(fact-oter <span class="number">1</span> <span class="number">2</span> <span class="number">6</span>)</span><br><span class="line">(fact-oter <span class="number">2</span> <span class="number">3</span> <span class="number">6</span>)</span><br><span class="line">(fact-oter <span class="number">6</span> <span class="number">4</span> <span class="number">6</span>)</span><br><span class="line">(fact-oter <span class="number">24</span> <span class="number">5</span> <span class="number">6</span>)</span><br><span class="line">(fact-oter <span class="number">120</span> <span class="number">6</span> <span class="number">6</span>)</span><br><span class="line">(fact-oter <span class="number">720</span> <span class="number">7</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>传统方法的计算过程如下<br>I<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">factorial</span> <span class="number">6</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">6</span> <span class="list">(<span class="keyword">factorial</span> <span class="number">5</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">6</span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">5</span> <span class="list">(<span class="keyword">factorial</span> <span class="number">4</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">6</span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">5</span> <span class="list">( * <span class="number">4</span> <span class="list">(<span class="keyword">factorial</span> <span class="number">3</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">6</span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">5</span> <span class="list">( * <span class="number">4</span> <span class="list">( * <span class="number">3</span><span class="list">(<span class="keyword">factorial</span> <span class="number">2</span>)</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">6</span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">5</span> <span class="list">( * <span class="number">4</span> <span class="list">( * <span class="number">3</span> <span class="list">( * <span class="number">2</span><span class="list">(<span class="keyword">factorial</span> <span class="number">1</span>)</span>)</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">6</span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">5</span> <span class="list">( * <span class="number">4</span> <span class="list">( * <span class="number">3</span> <span class="list">( * <span class="number">2</span> <span class="number">1</span>)</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">6</span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">5</span> <span class="list">( * <span class="number">4</span> <span class="list">( * <span class="number">3</span> <span class="number">2</span>)</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">6</span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">5</span> <span class="list">( * <span class="number">4</span>  <span class="number">6</span>)</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">6</span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">5</span> <span class="number">24</span>)</span>)</span></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">*</span></span> <span class="number">6</span> <span class="number">120</span>)</span></span><br><span class="line"><span class="number">720</span></span><br></pre></td></tr></table></figure></p>
<p>我门可以看出传统方法这种代换模型揭示出一种先逐步展开后收缩的形状。在这一计算过程中构造起一个推迟进行的操作所形成的链条，收缩阶段表现为这些匀速拿的实际执行。这种类型的计算过程由一个推迟执行的运算链条刻画，称为一个<em>递归计算过程</em>。要执行这种计算过程，解释器就需要维护好那些以后将要执行的操作的轨迹。在计算阶乘n!时候，推迟执行的乘法链条的长度也就是为保存其轨迹需要保存的信息量，这个长度随着n的值而线性增长（正比于n），就像计算中的步骤数目一样。这样的计算过程称为一个<em>线性递归过程</em>。</p>
<p>而我们的，新方法中并没有任何增长或者收缩。对于任何一个n，在计算过程汇总每一步，在我们需要保存的轨迹中，所有的东西就是变量product、counter和max-count的当前值。我们称这种过程为一个<em>迭代计算过程</em>。</p>
<p>在做迭代和递归之间的比较时，我们必须当心，不要弄混了<em>递归计算过程</em>的盖脸和<em>递归过程的概念。当我们说某个过程是递归的时候，论述的是一个语法形式上的事实，说明这个过程过程（直接或间接地）引用了该过程本身。</em>在说明一个计算过程具有某种模式时（例如，线性递归），我们说的是这一计算过程的进展方式，而不是相应的过程书写上语法形式（例如，线性递归），我们说的是这一计算过程的进展方式，而不是相应过程书写的语法形式。当我们说某个递归过程（例如fact-iter）将产生出一个迭代的计算过程时，可能会使人感到不舒服。然而这一计算过程确实是迭代的，因为它的状态能由其中的三个状态变量万全刻画，解释器在执行这一计算过程时，只需要保持这三个变量的轨迹就行了。</p>
<h6 id="小Tip">小Tip</h6><p>递归和迭代都是循环的一种。简单地说，递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环，而迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</p>
<p>递归循环中，遇到满足终止条件的情况时逐层返回来结束。迭代则使用计数器结束循环。当然很多情况都是多种循环混合采用，这要根据具体需求。</p>
<h4 id="树形递归">树形递归</h4><p>另一种常见的计算模式称为<em>树形递归</em>。作为例子，现在考虑斐波那契（Fibonacci）数序列的计算，这一序列中的每个数都是前面两个数之和：<br><br>0,1,1,2,3,5,8,13…..()</p>
<p>我们可以根据斐波那契的定义写出一个递归过程:</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span><span class="list">(<span class="keyword">fib</span> n)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">cond</span></span> <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">=</span></span> n <span class="number">0</span>)</span> <span class="number">0</span>)</span></span><br><span class="line">          <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">=</span></span> n <span class="number">1</span>)</span> <span class="number">1</span>)</span></span><br><span class="line">          <span class="list">(<span class="keyword"><span class="built_in">else</span></span> <span class="list">(<span class="keyword"><span class="built_in">+</span></span> <span class="list">(<span class="keyword">fib</span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> n <span class="number">1</span>)</span></span><br><span class="line">                   <span class="list">(<span class="keyword">fib</span> <span class="list">(<span class="keyword"><span class="built_in">-</span></span> n <span class="number">2</span>)</span>)</span>)</span>)</span>)</span>)</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/AirOil/Test_X/b7635c266e8a65ae9232aa27507e2f841c2fc74b/imgs/树形递归.jpeg" alt="树形递归"></p>
<p>我们可以从这个树状图中看出(fib 3)差不多是这里一半的工作，这一计算整个重复做了两次。事实上，不难证明，在这一过程中，计算(fib 1)和(fib 0)的次数（一般说，也就是上面树里的树叶的个数）正好是Fib(n+1)。我们可以证明Fib(n)值的增长相对于n是指数的。更准确地说，Fib(n)就是最接近ø<sup>2</sup> / √5的整数，其中：</p>
<p>ø = (1 + √5) / 2 ≈ 1.6180</p>
<p>ø<sup>2</sup> = ø + 1</p>
<p>所以我们可以规划出一种计算斐波那契的迭代计算过程，其基本思想就是用一对整数a和b, 将它们初始化为Fib(1) = 1 和 Fib(0) = 0,而后反复地同时使用下面变换规则：</p>
<p>a &lt;- a + b<br><br>b &lt;- a</p>
<p>不难证明，在n次应用了这些变换后, a和b将分别等于Fib(n+1)和Fib(n)。因此，我们可以用下面过程，以迭代的方式计算斐波那契数：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">fib</span> n)</span></span><br><span class="line">	<span class="list">(<span class="keyword">fib-iter</span> <span class="number">1</span> <span class="number">0</span> b)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">fib-iter</span> a b count)</span>)</span></span><br><span class="line">	<span class="list">(<span class="keyword"><span class="built_in">if</span></span> <span class="list">(<span class="keyword"><span class="built_in">=</span></span> count <span class="number">0</span>)</span></span><br><span class="line">		b)</span></span><br><span class="line">		<span class="list">(<span class="keyword">fib-iter</span> <span class="list">(<span class="keyword"><span class="built_in">+</span></span> a b)</span> a <span class="list">(<span class="keyword"><span class="built_in">-</span></span> count <span class="number">1</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>计算Fib(n)的这种方法是一个线性迭代。这两种方法在计算中所需的步骤上差异巨大－－后一方法想对于n为线性的，前一个的增长像Fib(n)一样快。</p>
<p><em>当我们考虑的是在层次结构性的数据操作，而不是对数操作时，将会发现树形递归计算过程是一种自然的、威力强大的工具。即使是对于数的计算，树形递归计算过程也可能帮助我们理解和设计程序，以斐波那契数程序为例，虽然第一个fib过程远比第二个低效，但它却更加直接了当。可以提供很好的思路。</em></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 张仲昊
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>