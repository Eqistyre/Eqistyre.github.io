<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SakuraNeko</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="SakuraNeko">
<meta property="og:url" content="http://eqistyre.github.io/page/2/index.html">
<meta property="og:site_name" content="SakuraNeko">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SakuraNeko">
<meta name="twitter:description">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://chuantu.biz/t2/18/1446819674x1822611272.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">张仲昊</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Eqistyre" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.talisk.cn">talisk斯温</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">人间二十年,花鸟风月</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">张仲昊</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://chuantu.biz/t2/18/1446819674x1822611272.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">张仲昊</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Eqistyre" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-DataStructure(1)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/16/DataStructure(1)/" class="article-date">
  	<time datetime="2015-12-16T02:38:35.000Z" itemprop="datePublished">2015-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/16/DataStructure(1)/">DataStructure(1)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Preface">Preface</h3><p>I will try to use English record my blog from today.</p>
<h3 id="Defination">Defination</h3><p>In computer science,a data structure is a particular way of organizing data in a computer so that it can be used efficiently.Data structures can implement one or more particular abstract data types(ADT),which are the means of specifying the the contract of operations and their complexity. In comparsion,a data structure is a concrete implementation of the contract provided by an ADT.</p>
<p>Different kinds of data structures are suited to different kinds of applications, examples:</p>
<p><li>Databases use B-tree indexes for small percentages of data retrieval.<br></li></p>
<p><li>compilers and databases use dynamic hash tables as look-up tables.<br></li></p>
<p>Usaually, efficient data structures are key to designing efficient algorithms.</p>
<h3 id="Overview">Overview</h3><p>Data structures are generally based on the ability of a computer fetch and store data at any place in its memory, specified by <em>pointer</em>-a bit string, representing a memory address. </p>
<h3 id="Examples">Examples</h3><p>There are numerous types of data structures, gennerally built upon simpler primitive data types:(just like a tress)</p>
<p><li>An array:a number of elements in a specific order, typically all of the same type.I think the array is one of the type we familiar with<br></li></p>
<p><li>An associative array:a more flexible variation on an array, in which name-value pairs can be added and deleted freely. A hash table is a common implementation of an associative array.<br></li></p>
<p><li>A record(also called tuple or struct):an aggregate data structure. A  record is a value that contains oher values, typically in fixed number and sequence and typically indexed by names. The elements of records are usually called fields or members(You can find struct in C, in C++ it have an advanced name class, but it also remmained in C++)<br></li></p>
<p><li>A union: a data structure that specifies which of a number of permitted primitive types may be stored in it’s instances,e.g. float or long integer. Contrast with a record, which could be defined to contain a float and an integer; whereas in a union, ther is only one value at time. Enough space is allocated to contain the widest member datatype(I will give a instance in c)</li></p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">number</span></span></span><br><span class="line">&#123;</span><br><span class="line">int x;</span><br><span class="line">long y;</span><br><span class="line">double z;</span><br><span class="line">&#125;;</span><br><span class="line">number num = (<span class="number">4</span>,<span class="number">15</span>,<span class="number">30.7</span>);</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><li>A tagged union: a variant union contains an additional field indicating its current type, for enhanced type safety.<br></li></p>
<p><li>A set: an abstract data structure that can store specific values, in no particular order and with no duplicate values.<br></li></p>
<p><li>A graph and a tree:linked abstract data structures composed of nodes. Each node contains a value and one or more pointers to other nodes arranged in a hierarchy. Graphs can be used to represent networks, while variants of trees can be used for sorting and searching, having their nodes arranged in some relative order based on their values.<br></li></p>
<p><li>A class: a data structure that contains data fields, like a record, as well as various methods which operate on the contents of the record. In the context of object-oriented programming, records are known as plain old data structures to distinguish them from classes.<br><br></li></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-杂感12.15" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/15/杂感12.15/" class="article-date">
  	<time datetime="2015-12-14T16:38:35.000Z" itemprop="datePublished">2015-12-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/15/杂感12.15/">吐槽</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="我现在很想吐槽">我现在很想吐槽</h3><p>我现在很想吐槽！我现在很想吐槽！我现在很想吐槽！我现在很想吐槽！</p>
<p>没有猫也没有她，自己还多了一堆事。</p>
<p>这事情自己应付了就行。不需要投入太多的精力，自己还是要好好去学习。这事情能获取学校多少帮助就争取获取多少。</p>
<p>听着周杰伦的的《阳光宅男》，自己觉得自己一个唱首《月光男孩》。自己越来越空虚了。好烦！</p>
<p>算了还是好好写代码。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-颓废的两天" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/10/颓废的两天/" class="article-date">
  	<time datetime="2015-12-10T07:38:35.000Z" itemprop="datePublished">2015-12-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/10/颓废的两天/">十二月中旬杂感</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="颓废的两天（12-4）">颓废的两天（12.4）</h3><p>这两天真的很颓废，没有去做什么事情，，Github上面的进度也断了。主要原因是我不应该去看小说啊啊啊。小说真的很能让自己颓废掉。</p>
<p>说下自己未来几天的计划吧</p>
<p><li>1.去看看数字逻辑周六（也就是明天）要去做数字逻辑的实验了<br></li></p>
<p><li>2.还要去复习数据结构和C++，虽然我可以考过这两门，但是太多课没有去上了<br></li></p>
<p><li>3.Osmanthus项目先停一会吧<br></li></p>
<p><li>4.Lua脚本扩展那本书看完，那本书挺基础的<br></li></p>
<h3 id="活过来了（12-10）">活过来了（12.10）</h3><p>终于终于颓废的几天过去了，可以重新好好的做事了，那些奇奇怪怪的事情也都干完了。不过自己还是要注意要考四级了，好好努力咯加油少年</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-雾草！又尼玛是一个难题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/01/雾草！又尼玛是一个难题/" class="article-date">
  	<time datetime="2015-12-01T06:38:35.000Z" itemprop="datePublished">2015-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/01/雾草！又尼玛是一个难题/">Cocos-2dx杂感</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="雾草！又尼玛是一个难题">雾草！又尼玛是一个难题</h3><p>首先还是欢呼一下时间已经进入到十二月份了吧！马上就要结课了，不过这也代表着很快自己就要去考万恶的四级了～雾草，为什么还要考四级啊，郁闷脸。</p>
<p>好吧，说下自己碰到的问题吧＝＝。自己找不到this指向的对象了。首先来看下源代码吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> GameRunning::init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//////////////////////////////</span></span><br><span class="line">    <span class="comment">// 1. super init first</span></span><br><span class="line">    <span class="keyword">if</span> ( !Layer::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> RootNode = CSLoader::createNode(<span class="string">"GameRunning.csb"</span>);</span><br><span class="line">    <span class="keyword">auto</span> GameRunningScene = Scene::create();</span><br><span class="line">    GameRunningScene-&gt;addChild(RootNode);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> GameRunningLayerNode = CSLoader::createNode(<span class="string">"GameRunningLayer.csb"</span>);</span><br><span class="line">    <span class="keyword">auto</span> GameRunningLayer = Layer::create();</span><br><span class="line">    GameRunningLayer-&gt;addChild(GameRunningLayerNode);;</span><br><span class="line">    GameRunningScene-&gt;addChild(GameRunningLayer);</span><br><span class="line">    <span class="keyword">this</span>-&gt;addChild(GameRunningScene);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    CharacterLayer *CharacterLayer = CharacterLayer::create();</span></span><br><span class="line"><span class="comment">//    this-&gt;addChild(CharacterLayer);</span></span><br><span class="line">    <span class="keyword">auto</span> CharacterNode = cocos2d::CSLoader::createNode(<span class="string">"CharacterLayer.csb"</span>);</span><br><span class="line">    <span class="keyword">auto</span> CharacterLayer = Layer::create();</span><br><span class="line">    CharacterLayer-&gt;addChild(CharacterNode);</span><br><span class="line">    <span class="keyword">this</span>-&gt;addChild(CharacterLayer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是自己写的一个程序哈，其中通过<code>this-&gt;addChilde(Character)</code>我们添加了一个CharacterLayer。但是这里的this到底指的是什么呢，我在这里推测这里的this指的应该是layer这样的东西。然后我找到了头文件中的一段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> GameRunning : <span class="keyword">public</span> cocos2d::Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// there's no 'id' in cpp, so we recommend returning the class instance pointer</span></span><br><span class="line">    <span class="keyword">static</span> cocos2d::<span class="function">Scene* <span class="title">createScene</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Here's a difference. Method 'init' in cocos2d-x returns bool, instead of returning 'id' in cocos2d-iphone</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//implement the "static create()" method manually</span></span><br><span class="line">    CREATE_FUNC(GameRunning);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/* defined(____GameRunning__) */</span></span></span><br></pre></td></tr></table></figure>
<p>我们发现在这里面有一个<code>CREATE_FUNC(GameRunning)</code>然后我把它注释了，之后发现游戏画面中通过this添加的图层场景什么鬼的都没有了，于是我推测CREATE_FUNC就是关键。于是我就去查询了CREATE_FUNC()的源码。CREATE_FUNC()是一个宏定义，其定义如下：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @def CREATE_FUNC(__TYPE__)</span><br><span class="line"> * Define a create function for a specific type, such as Layer.</span><br><span class="line"> *</span><br><span class="line"> * @param __TYPE__  class type to add create(), such as Layer.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">#define CREATE_FUNC(__TYPE__) \</span></span><br><span class="line">static __TYPE__* create() <span class="string">\</span></span><br><span class="line">&#123; <span class="string">\</span></span><br><span class="line">    __TYPE__ *pRet = <span class="keyword">new</span>(<span class="attribute">std</span>::nothrow) __TYPE__(); <span class="string">\</span></span><br><span class="line">    <span class="keyword">if</span> (pRet &amp;&amp; pRet-&gt;init()) <span class="string">\</span></span><br><span class="line">    &#123; <span class="string">\</span></span><br><span class="line">        pRet-&gt;autorelease(); <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> pRet; <span class="string">\</span></span><br><span class="line">    &#125; <span class="string">\</span></span><br><span class="line">    <span class="keyword">else</span> <span class="string">\</span></span><br><span class="line">    &#123; <span class="string">\</span></span><br><span class="line">        <span class="keyword">delete</span> pRet; <span class="string">\</span></span><br><span class="line">        pRet = NULL; <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> NULL; <span class="string">\</span></span><br><span class="line">    &#125; <span class="string">\</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看见这是一个创建一个函数给一个详细类，如层。我先闲着无聊，替换下吧好理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> GameRunning* <span class="title">create</span><span class="params">()</span> </span><br><span class="line"></span>&#123; </span><br><span class="line">    GameRunning *pRet = <span class="keyword">new</span>(<span class="built_in">std</span>::nothrow) GameRunning(); </span><br><span class="line">    <span class="keyword">if</span> (pRet &amp;&amp; pRet-&gt;init()) </span><br><span class="line">    &#123; </span><br><span class="line">        pRet-&gt;autorelease(); </span><br><span class="line">        <span class="keyword">return</span> pRet; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">delete</span> pRet; </span><br><span class="line">        pRet = <span class="literal">NULL</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="补充一点小知识点">补充一点小知识点</h3><p><em>今天写代码的时候遇见了很多的C++知识，发现自己都已经忘记了，自己还是回顾下这些C++知识吧</em></p>
<p><li>1.public成员可以通过“.”运算符进行调用。</li></p>
<p><li>2.类中进行赋值会出现非静态成员初始化时的错误。</li></p>
<p><li>3.c++中由于数据与函数封装在一起会出现。</li></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">class</span> Circle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> radius;</span><br><span class="line">	</span><br><span class="line">	Circle() &#123;</span><br><span class="line">		radius = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Circle(<span class="keyword">double</span> newRadius) &#123;</span><br><span class="line">		radius = newRadius;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> radius * radius * <span class="number">3.14</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以直接使用getArea()方法而不去添加参数。</p>
<p><li>4.类的构造函数不能够有返回值。</li></p>
<p><li>5.对象指针什么鬼的：</li></p>
<p>定义：指向类的成员的指针。在C++中，可以说明指向类的数据成员和成员函数的指针。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-今天就说说今天的一些小收获吧" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/29/今天就说说今天的一些小收获吧/" class="article-date">
  	<time datetime="2015-11-29T14:38:35.000Z" itemprop="datePublished">2015-11-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/29/今天就说说今天的一些小收获吧/">Cocos-2dx杂感</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="今天就说说今天的一些小收获吧">今天就说说今天的一些小收获吧</h3><p>首先关于界面切换的问题。我们创建一个SceneManager类，然后在这个类里面写如下代码。下面我会去解释这些代码的意思的。（算了我还是直接去注释这些代码吧，如果不去注释这些代码的话，写起来会比较麻烦的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先我们在宏中要将我们需要包含的代码放进去，只有这样在后续的使用中，使用场景类的话才可以成功</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"SceneManager.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"GameRunning.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"OsmanthusBeginner.h"</span></span></span><br><span class="line"></span><br><span class="line">SceneManager* SceneManager::mSceneManager = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">SceneManager* SceneManager::sharedSceneManager()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mSceneManager == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mSceneManager = <span class="keyword">new</span> SceneManager();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSceneManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SceneManager::changeScene( EnumSceneType enScenType )</span><br><span class="line">&#123;</span><br><span class="line">    changeScene(enScenType, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SceneManager::changeScene( EnumSceneType enScenType, <span class="keyword">bool</span> isTrans )</span><br><span class="line">&#123;</span><br><span class="line">    changeScene(enScenType, isTrans, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SceneManager::changeScene( EnumSceneType enScenType, <span class="keyword">bool</span> isTrans, <span class="keyword">float</span> time )</span><br><span class="line">&#123;</span><br><span class="line">    Scene* pScene = getSceneByType(enScenType);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pScene == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TextureCache::sharedTextureCache()-&gt;removeUnusedTextures();</span><br><span class="line">    Director* pDirector = Director::getInstance();</span><br><span class="line">    Scene* curScene = pDirector-&gt;getRunningScene();</span><br><span class="line">    <span class="keyword">if</span>(curScene == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pDirector-&gt;runWithScene(pScene);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isTrans)</span><br><span class="line">        &#123;</span><br><span class="line">            pDirector-&gt;replaceScene(TransitionFade::create(time, pScene));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pDirector-&gt;replaceScene(pScene);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SceneManager::pushScene( EnumSceneType enSceneType )</span><br><span class="line">&#123;</span><br><span class="line">    Scene* pScene = getSceneByType(enSceneType);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pScene == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Director::getInstance()-&gt;pushScene(pScene);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SceneManager::popScene()</span><br><span class="line">&#123;</span><br><span class="line">    Director::getInstance()-&gt;popScene();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Scene* SceneManager::getSceneByType( EnumSceneType enSceneType )</span><br><span class="line">&#123;</span><br><span class="line">    Scene* pScene = Scene::create();</span><br><span class="line">    Layer *pLayer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (enSceneType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> en_OsmanthusBeginner:</span><br><span class="line">            pLayer = OsmanthusBeginner::create();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> en_GameRunning:</span><br><span class="line">            pLayer = GameRunning::create();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pScene-&gt;addChild(pLayer);</span><br><span class="line">    <span class="keyword">return</span> pScene;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有就是在相应的IOS中把相应的plist中的lanchImage进行替换，活着你可以在plist中重写</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-各种排序" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/29/各种排序/" class="article-date">
  	<time datetime="2015-11-28T16:40:35.000Z" itemprop="datePublished">2015-11-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/29/各种排序/">考试之前看的各种排序</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="&lt;一&gt;插入排序">&lt;一&gt;插入排序</h3><p>有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">voidinsertion_sort(intarray[],intfirst,intlast)</span><br><span class="line">&#123;</span><br><span class="line">inti,j;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(i = first+<span class="number">1</span>; i &lt; last ; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp=<span class="built_in">array</span>[i];</span><br><span class="line">j=i-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//与已排序的数逐一比较，大于temp时，该数移后</span></span><br><span class="line"><span class="keyword">while</span> ((j&gt;=<span class="number">0</span>) &amp;&amp; (<span class="built_in">array</span>[j]&gt;temp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">array</span>[j+<span class="number">1</span>]=<span class="built_in">array</span>[j];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存在大于temp的数</span></span><br><span class="line"><span class="keyword">if</span>(j!=i-<span class="number">1</span>)</span><br><span class="line">&#123;<span class="built_in">array</span>[j+<span class="number">1</span>]=temp;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="&lt;二&gt;冒泡排序">&lt;二&gt;冒泡排序</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="&lt;三&gt;选择排序">&lt;三&gt;选择排序</h3><h3 id="&lt;四&gt;快速排序">&lt;四&gt;快速排序</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-今天的我是非常开心的我" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/29/今天的我是非常开心的我/" class="article-date">
  	<time datetime="2015-11-28T16:38:35.000Z" itemprop="datePublished">2015-11-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/29/今天的我是非常开心的我/">Cocos-2dx中踩的又一个坑，关于lambda函数</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="今天的我是非常开心的我">今天的我是非常开心的我</h3><p>解决了一个bug啦啦啦，今天在写Cocos-2dx时候遇到了非常非常多的问题，今天我终于发现了解决这些问题的方法了。首先是关于那些坑爹的回调函数，那些回调函数真的是非常非常的坑人啊！！！雾草，如果按照它官方教材上的解决方法估计会是一种说不出的酸爽。最后我觉得还是使用监听函数会比较方便了。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BeginnerContinueBtn-&gt;addTouchEventListener([=](Ref* pSender,<span class="string">cocos2d:</span>:<span class="string">ui:</span>:<span class="string">Widget:</span>:TouchEventType type) &#123;</span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">cocos2d:</span>:<span class="string">ui:</span>:<span class="string">Widget:</span>:<span class="string">TouchEventType:</span>:<span class="string">BEGAN:</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">cocos2d:</span>:<span class="string">ui:</span>:<span class="string">Widget:</span>:<span class="string">TouchEventType:</span>:<span class="string">MOVED:</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">cocos2d:</span>:<span class="string">ui:</span>:<span class="string">Widget:</span>:<span class="string">TouchEventType:</span>:<span class="string">ENDED:</span></span><br><span class="line">                <span class="comment">//Director::getInstance()-&gt;replaceScene(BeginnerScene);</span></span><br><span class="line">                removeChild(BeginnerScene);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">cocos2d:</span>:<span class="string">ui:</span>:<span class="string">Widget:</span>:<span class="string">TouchEventType:</span>:<span class="string">CANCELED:</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="label">                </span><br><span class="line">            default:</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们来看看这个事件监听器吧！<br><br>在这个事件监听器中，我们可以知道我们向BeginnerContinueBtn上添加了一个事件监听器，这里的实现，我们是使用lambda函数来进行，其实我在以前写JS的时候也是写过lambda函数的哦如下：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">double</span> = <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>* x; &#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个典型的lambda函数咯，在这个函数中函数是没有函数的名字啦！那么在C++中lambda函数的实现如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T::ForEach([<span class="link_label">&amp;</span>](<span class="link_url">T *what</span>) &#123;</span><br></pre></td></tr></table></figure>
<p>不过当我使用了lambda函数之后出现了一个奇怪的错误！编译错误警告如下：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'func'</span> cannot <span class="keyword">be</span> implicitly captured because <span class="keyword">no</span> default capture <span class="built_in">mode</span> <span class="built_in">has</span> been specified</span><br></pre></td></tr></table></figure>
<p>经过在stackoverflow上的查找我发现了事实的真相！！回答如下</p>
<p>You need to specify how to capture func into the lambda.</p>
<p>[] don’t capture anything</p>
<p>[&amp;] capture-by-reference</p>
<p>[=] capture-by-value (copy)</p>
<p>T::ForEach(<a href="T *what">&amp;</a> {<br>I’d also recommend that you should send func by const reference.</p>
<p>static void ComputeGenericDropCount(const function<void(npc *,="" int)="">&amp; func)</void(npc></p>
<p>也就是说在这里[] 表示不传递。[&amp;]表示按引用传递，[=]表示按值传递。于是吼吼吼我的这个bug就修好了！～～</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Cocos2d-x的简单知识点1126" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/24/Cocos2d-x的简单知识点1126/" class="article-date">
  	<time datetime="2015-11-24T08:38:35.000Z" itemprop="datePublished">2015-11-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/24/Cocos2d-x的简单知识点1126/">Cocos2d-x的简单知识点&lt;二&gt;</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="吐槽">吐槽</h3><p>先来吐槽一下。。Cocos的版本更新实在是太快，导致书上的很多东西都找不到了，这让我感到很忧伤。还有这两天的天气也的确是冻成狗哈，自己仍旧作死的穿着很少的两件衣服。</p>
<h3 id="正片">正片</h3><p>这次的正片基本上是自己边读文档边写的，支持的版本为v2.3.3.0。</p>
<p><li>首先说下UI的布局与多分辨率适配吧。<br><br>我们打开了Cocos编辑器后会发现有四个钉和中间的两个拉伸条（话说我当时就没有看到这个拉伸条呢）一共六个属性。<br><br>1.当打开其中一个任意图钉时，当前节点与父节点的对应边的距离即被固定。当父节点的大小被修改时，当前节点与父节点对应边的距离总是不变。<br><br>2.当打开其中的任意两个相对的图钉，当前节点与父节点对应的两边距离成固定比例。即当修改父节点的大小时，当前节点到父节点对应两条边的距离之比总是不变的。<br><br>3.当开启中间任意一条拉伸条，如横向拉伸条，节点的宽度与父节点的宽度之比固定不变。<br></li></p>
<p>还有我们要明白：在Cocos2d-x中有两种分辨率：设备分辨率，屏幕分辨率。设备分辨率即当前游戏所运行平台的实际分辨率；设计分辨率就是我们设计游戏的分辨率。</p>
<p>设计分辨率一般在启动时进行设置：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">APPDelegate::</span>applicationDidFinishLauching</span><br></pre></td></tr></table></figure>
<p>中进行，代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">director -&gt; <span class="function"><span class="title">getOpenGlView</span><span class="params">()</span></span> -&gt;<span class="function"><span class="title">setDesignResolutionSize</span><span class="params">(<span class="number">960</span>, <span class="number">640</span>, ResolutionPolicy::FIXED_HEIGHT)</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以看出来这里的策略和cocos2d-js是一样的，不过我现在却记不得cocos2d-js里的策略了。</p>
<p>下面来说说cocos2d-x中的解决方案吧</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.计算游戏界面在缩放至充满屏幕的情况下X、Y轴的缩放率:</span></span><br><span class="line">_scaleX= (<span class="built_in">float</span>)_screenSize.<span class="variable">width</span>/ _designResolutionSize.<span class="variable">width</span>;</span><br><span class="line">_scaleY= (<span class="built_in">float</span>)_screenSize.<span class="variable">height</span>/ _designResolutionSize.<span class="variable">height</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.根据设配策略，调整缩放率和设计分辨率:</span></span><br><span class="line"><span class="keyword">if</span>(_resolutionPolicy== ResolutionPolicy::NO_BORDER)</span><br><span class="line">&#123;<span class="comment">//将X、Y轴缩放值设置为其中的最大者</span></span><br><span class="line">    _scaleX = _scaleY = MAX(_scaleX,_scaleY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(_resolutionPolicy== ResolutionPolicy::SHOW_ALL)</span><br><span class="line">&#123;<span class="comment">//将X、Y轴缩放值设置为其中的最小者</span></span><br><span class="line">    _scaleX = _scaleY = MIN(_scaleX,_scaleY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( _resolutionPolicy == ResolutionPolicy::FIXED_HEIGHT) &#123;</span><br><span class="line">    _scaleX = _scaleY;<span class="comment">//将X、Y轴缩放值固定为Y轴缩放值，调整设计分辨率的宽度，使设计分辨率的宽度在缩放后依然能够充满屏幕。</span></span><br><span class="line">    _designResolutionSize.<span class="variable">width</span>= ceilf(_screenSize.<span class="variable">width</span>/_scaleX);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( _resolutionPolicy == ResolutionPolicy::FIXED_WIDTH) &#123;</span><br><span class="line">    _scaleY= _scaleX;<span class="comment">//将X、Y轴缩放值固定为X轴缩放值，调整设计分辨率的高度，使设计分辨率的高度在缩放后依然能够充满屏幕。</span></span><br><span class="line">    _designResolutionSize.<span class="variable">height</span>= ceilf(_screenSize.<span class="variable">height</span>/_scaleY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他缩放策略：EXACT_FIT不作调整</span></span><br></pre></td></tr></table></figure>
<p>下面来说说加载界面吧！<br><br>加载界面在HelloWorld::init中进行：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto rootNode= CSLoader<span class="number">::c</span>reateNode("MainScene.csb")<span class="comment">;</span></span><br><span class="line">auto size= Director<span class="number">::</span>getInstance()-&gt;getVisibleSize()<span class="comment">;</span></span><br><span class="line">//设置加载出来的洁面的ContentSize</span><br><span class="line">rootNode-&gt;setContentSize(size)<span class="comment">;</span></span><br><span class="line">//调用对rootNode调用ui<span class="number">::</span>Helper<span class="number">::d</span>oLayout对加载出来的界面进行处理</span><br><span class="line">ui<span class="number">::</span>Helper<span class="number">::d</span>oLayout(rootNode)<span class="comment">;</span></span><br><span class="line">addChild(rootNode)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><li>再来说下九宫格使用吧</li></p>
<p>九宫格使用可以节省大量资源空间。原理如下：</p>
<p>九宫格是一种能够使本来拉伸后会变形的图片，经过一定的处理后，拉伸后不变形的技术。 九宫格放大时四个角的四个切片向四个方向延伸，到达新的位置，然后上下两边的切片水平拉伸，左右两侧的切片垂直拉伸，中间的位图放大铺满剩余区域。</p>
<p><li>回调特性的使用<br>我觉的这个使用方法特别有毛病，其代码的繁琐已经很难让人接受了，但是还是写出来吧。</li></p>
<p>1.首先我们在编辑器中为根节点添加类名（高级属性-&gt;回调特性-&gt;自定义类）如MyClass。<br><br>2.我们选中自己想要设置回调特性的控件，在其回调方法中，选择接受的回调类型以及输入回调方法的名称：如Touch方法，名称为onTouch:</p>
<p>然后就轮到我们在xcode中进行了：<br><br>1.我们在C++中,创建一个自己的自定义类：<br><br>这个类必须遵循如下要求：<br><br>a.继承WidgetCallBackHandlerProtocol和Node（或者其他继承自Node的类）<br><br>b.重写如下接口：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">onLocateTouchCallback</span></span><br><span class="line"><span class="built_in">on</span>LocateClickCallback</span><br><span class="line"><span class="built_in">on</span>LocateEventCallback</span><br></pre></td></tr></table></figure>
<p>返回对Touch,Click,Event三种时间的处理函数。（只需要写自己用到的回调类型就行）。<br><br><br>eg:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h file</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> __TestCpp__MyClass__</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __TestCpp__MyClass__</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"cocos2d.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"Cocos Studio/Cocos Studio.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"Cocos Studio/WidgetCallBackHandlerProtocol.h"</span></span></span><br><span class="line"><span class="keyword">class</span> MyClass : <span class="keyword">public</span> cocos2d::Node, <span class="keyword">public</span> Cocos Studio::WidgetCallBackHandlerProtocol &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CREATE_FUNC(MyClass)</span><br><span class="line">	MyClass();</span><br><span class="line">	<span class="keyword">virtual</span> cocos2d::ui::Widget::<span class="function">ccWidgetTouchCallback <span class="title">onLocateTouchCallback</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;callBackName)</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span> cocos2d::ui::Widget::<span class="function">ccWidgetClickCallback <span class="title">onLocateClickCallback</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;callBackName)</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span> cocos2d::ui::widget::<span class="function">ccWidgetClickCallback <span class="title">onLocateEventCallback</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;callBackName)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onTouch</span><span class="params">(cocos2d::Ref* sender, cocos2d::ui::Widget::TouchEventType type)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(cocos2d::Ref* sender)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(cocos2d::Ref* sender, <span class="keyword">int</span> eventType)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; _touchTypes;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> _click;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; _eventTypes</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp file</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"MyClass.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ui/UIText.h"</span></span></span><br><span class="line"></span><br><span class="line">USING_NS_CC;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cocos2d::ui;</span><br><span class="line"></span><br><span class="line">MyClass::Myclass() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::ccWidgetTouchCallback Myclass::onLocateTouchCallback(<span class="keyword">const</span> <span class="built_in">string</span> &amp;callBackName) &#123;</span><br><span class="line">	<span class="comment">//判断事件名，返回响应的函数</span></span><br><span class="line">	<span class="keyword">if</span> (callBackName == <span class="string">"onTouch"</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> CC_CALLBACK_2(MyClass::onTouch, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::ccWidgetClickCallback MyClass::onLocateClickCallback(<span class="keyword">const</span> <span class="built_in">string</span> &amp;callBackName) &#123;</span><br><span class="line">	<span class="keyword">if</span> (callBackName == <span class="string">"onClick"</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> CC_CALLBACK_1(MyClass::onCLic, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::ccWidgetEventCallback MyClass::onLocateEventCallback(<span class="keyword">const</span> <span class="built_in">string</span> &amp;callBackName) &#123;</span><br><span class="line">	<span class="keyword">if</span> (callBackName == <span class="string">"onEvent"</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> CC_CALLBACK_2(MyClass::onEvent, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyClass::onTouch(cocos2d::Ref* object, cocs2d::ui::Widget::TouchEventType type) &#123;</span><br><span class="line">	CCLOG(<span class="string">"onTouch"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyClass::onClick(cocos2d::Ref* sender) &#123;</span><br><span class="line">	CCLOG(<span class="string">"onClick"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyClass::onEvent(cocos2d::Ref* sender, <span class="keyword">int</span> eventType) &#123;</span><br><span class="line">	CCLOG(<span class="string">"onEvent"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.为刚刚创建好的类创建工厂类：</p>
<p>这个类必须继承Cocos Studio::NodeReader,并且重写如下三个接口<br><br>getInstance —— 返回工厂类的单例<br><br>purge —— 销毁工厂类<br>createNodeWithFlatBuffers —— 创建第3步编写的类，并调用setPropsWithFlatBuffers</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h file</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> __cocos2d_libs__MyClassReader__</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __cocos2d_libs__MyClassReader__</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"cocos2d.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"Cocos Studio/CocosStudioExport.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"Cocos Studio/WidgetReader/NodeReader/NodeReader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MyClassReader : <span class="keyword">public</span> Cocos Studio::NodeReader &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MyClassReader() &#123;</span><br><span class="line">	&#125;;</span><br><span class="line">	~MyclassReader() &#123;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> MyClassReader* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">purge</span><span class="params">()</span></span>;</span><br><span class="line">	cocos2d::<span class="function">Node* <span class="title">createNodeWithFlatBuffers</span><span class="params">(<span class="keyword">const</span> flatbuffers::Table* nodeOptions)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/*defined(_cocos2d_libs__MyClassReader__)*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp file</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"MyClassReader.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line">USING_NS_CC</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> MyClassReader* _instanceMyClassReader = <span class="literal">nullptr</span>;</span><br><span class="line">MyClassReader* MyClassReader::getInstance() &#123;</span><br><span class="line">	<span class="keyword">if</span> (!_instanceMyClassReader) &#123;</span><br><span class="line">		_instanceMyClassReader = <span class="keyword">new</span> MyClassReader();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _instanceMyClassReader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyClassReader::purge() &#123;	CC_SAFE_DELETE(_instanceMyClassReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* MyClassReader::createNodeWithFlatBuffers(<span class="keyword">const</span> flatbuffers::Table *nodeOptions) &#123;</span><br><span class="line">	MyClass* node = MyClass::create();</span><br><span class="line">	setPropsWithFlatBuffers(node, nodeOptions);</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.在加载节点之前注册这个接口CSLoader中</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CSLoader*<span class="instruction"> instance </span>=<span class="function"> CSLoader::getInstance(</span><span class="function">)</span>;</span><br><span class="line">//注意第一个参数必须是第一步填写的自定义类名加“Reader ”如上述的<span class="string">"MyClassReader"</span> </span><br><span class="line">instance<span class="function">-&gt;registReaderObject(</span><span class="string">"MyClassReader"</span>,(ObjectFactory::Instance<span class="function">)</span>MyClassReader::getInstance<span class="function">)</span>;</span><br></pre></td></tr></table></figure>
<p>4.使用CreateNode加载你的节点，因为你的自定义类的create已经委托给工厂类，只要你注册工厂类的时候没写错，工厂类会在createNode里边create你的自定义类并调用onLocateTouchCallback，onLocateClickCallback，onLocateEventCallback实现代码回调与编辑器的绑定。</p>
<h3 id="New_Way">New Way</h3><p>是不是感觉刚刚这个方法实在是太过于麻烦了呢，现在我们找到一种新的方法，新版本的cocos2d中提供了一种新的资源加载方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node* CSLoader::createNode(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;filename, <span class="keyword">const</span> ccNodeLoadCallback &amp;callback)</span><br></pre></td></tr></table></figure>
<p>相比较于之前的版本里，我们发现这里多了一个回调函数的参数<code>const ccNodeLoadcallback &amp;callback</code>阅读完源码之后我们会知道在加载完一个节点后，框架会将节点简单地回调给这个函数(除根节点外)。这样，利用这个参数，我们可以在加载资源的过程中对正在加载的节点做一些修饰处理。</p>
<p>CSloader中原有回调特性的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget* widget = <span class="keyword">dynamic_cast</span>(node);</span><br><span class="line"><span class="keyword">if</span> (widget) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> callbackName = widget-&gt;getCallbackName();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> callbackType = widget-&gt;getCallbackType();</span><br><span class="line">    bindCallback(callbackName, callbackType, widget, _rootNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边的两个函数：getCallbackName，getCallbackType，取出来的就是我们在Cocos中所填写的回调参数信息。然后我们尝试着去绑定它们。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node既是当前加载出来的节点</span></span><br><span class="line">CSLoader::createNode(root_path,[<span class="keyword">this</span>](Node *node) &#123;</span><br><span class="line">	Widget* widget = <span class="keyword">dynamic_cast</span>(node);<span class="comment">//尝试将节点转化为widget类型</span></span><br><span class="line">	<span class="keyword">if</span> (widget)&#123;</span><br><span class="line">		<span class="comment">//获取回调特性相关属性的信息。</span></span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span> callbackName = widget-&gt;getCallbackName();</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span> callbackType = widget-&gt;getCallbackType();</span><br><span class="line">		<span class="comment">//根据上述信息进行绑定。</span></span><br><span class="line">		<span class="keyword">this</span>.bindCallback(callbackName, callbackType, widget);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后在当前类实现一个bindCallback函数，用callbackName和callbackType进行一些字符串比对操作，找到一个合适的函数，丢给widget做监听，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MyScene::bindCallback(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;callbackName,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;callbackType,widget) &#123;</span><br><span class="line">	<span class="keyword">if</span>(callbackName == <span class="string">"animal1"</span> &amp;&amp; callbackType == <span class="string">"Click"</span>)&#123;</span><br><span class="line">		<span class="comment">//假定有一个playAnimal1的接口</span></span><br><span class="line">		widget-&gt;addClickEventListener(CC_CALLBACK_2(MyScene::playAnimal1,<span class="keyword">this</span>));	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(callbackName == <span class="string">"animal2"</span> &amp;&amp; callbackType == <span class="string">"Click"</span>) &#123;</span><br><span class="line">		<span class="comment">//假定有一个playAnimal2的接口</span></span><br><span class="line">	widget-&gt;addClickEventListener(CC_CALLBACK_2(MyScene::playAnimal2,<span class="keyword">this</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实例">实例</h6><p>下面我们使用这种新的方法进行绑定按钮的回调事件操作。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Cocos2d-x的简单知识点1123" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/19/Cocos2d-x的简单知识点1123/" class="article-date">
  	<time datetime="2015-11-19T12:38:35.000Z" itemprop="datePublished">2015-11-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/19/Cocos2d-x的简单知识点1123/">Cocos2d-x的简单知识点&lt;一&gt;</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="先补充一些c++的知识点吧">先补充一些c++的知识点吧</h3><h5 id="c++继承"><li>c++继承</li></h5><p>通过继承机制，可以利用已有的数据类型来定义新的数据类型。所定义的新的数据类型不仅拥有新定义的成员，而且还同时拥有旧的成员。我们称已存在的用来派生新类的类为基类，又称为父类。由已存在的类派生出的新类称为派生类，又称为子类。</p>
<p>单继承的定义格式如下</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="inheritance">&lt;</span>派生类名&gt; : <span class="inheritance">&lt;</span>继承方式&gt; <span class="inheritance">&lt;</span>基类名&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类新定义成员&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，class是关键词，&lt;派生类名&gt;是新定义的一个类的名字，它是从&lt;基类名&gt;中派生的，并且按指定的&lt;继承方式&gt;派生的。&lt;继承方式&gt;常使用如下三种关键字给予表示:</p>
<p>public 表示公有继承；<br><br>private 表示私有继承；<br><br>protected 表示保护继承；<br></p>
<p>exp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyHelloWorldScene : <span class="keyword">public</span> Layer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*通过静态的scene函数，创建一个场景对象*/</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> Scene* <span class="title">createScene</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*MyHelloWorldScene的初始化工作都在init里执行*/</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*调用宏CREATE_FUNC定义create函数*/</span></span><br><span class="line">	CREATE_FUNC(MyHelloWorldScene);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>多继承的定义格式如下：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="inheritance">&lt;</span>派生类名&gt; : <span class="inheritance">&lt;</span>继承方式1&gt; <span class="inheritance">&lt;</span>基类名1&gt;, <span class="inheritance">&lt;</span>继承方式2&gt; <span class="inheritance">&lt;</span>基类名2&gt;,…</span></span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类新定义成员&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，多继承与单继承的区别从定义格式上看，主要是多继承的基类多余一个。<br><br>如果省略继承方式，对’class’将采用私有继承，对’struct’采用公有继承。<br><br>也就是说</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span>&#123;&#125;;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span>&#123;&#125;;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:<span class="title">Base1</span>,<span class="title">Base2</span>&#123;&#125;;</span></span><br></pre></td></tr></table></figure>
<p>那么，Derive类将私有继承Base1,公有继承Base2。相当于：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">classDerive </span>:<span class="value"> private Base1,public Base2&#123;</span><br><span class="line"><span class="comment">/*派生类新定义成员*/</span></span><br><span class="line">&#125;</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="多态"><li>多态</li></h5><p>多态按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同实现方式即为多态。多态性是允许将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是：允许将子类类型的指针赋值给弗雷类型的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ThisisA."</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B:<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ThisisB."</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(intargc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">	A* a = <span class="keyword">new</span> B();</span><br><span class="line">	a -&gt; foo();</span><br><span class="line">	<span class="keyword">if</span>(a != <span class="literal">NULL</span>)</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="explicit"><li>explicit</li></h5><p>C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。声明为explicit的构造函数不能在隐式转换中使用。</p>
<p>explicit构造函数是用来防止隐式转换的。请看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Test1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test1(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		num = n;</span><br><span class="line">	&#125;<span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Test2 &#123;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		num = n;</span><br><span class="line">	&#125;<span class="comment">//explicit(显式)构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Test1 t1 = <span class="number">12</span>;<span class="comment">//隐式调用其构造函数,成功</span></span><br><span class="line">	Test2 t2 = <span class="number">12</span>;<span class="comment">//编译错误,不能隐式调用其构造函数</span></span><br><span class="line">	<span class="function">Test2 <span class="title">t2</span><span class="params">(<span class="number">12</span>)</span></span>;<span class="comment">//显式调用成功</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="构造函数（这里只说C++的构造函数）"><li>构造函数（这里只说C++的构造函数）</li></h5><p>1,构造函数的命名必须和类名完全相同。<br><br>2,构造函数的功能主要用于在类的对象创建时定义初始化的状态。<br><br>3,<strong>构造函数不能被直接调用，必须通过new运算符在创建对象时才会调用；而一般的方法是在程序执行到它的时候被调用；</strong><br>4,当定义一个类的时候，通常情况下都会显示该类的构造函数，并在函数中指定初始化的工作也可省略。</p>
<p>C++构造函数：<br><br>C++语言为类提供的构造函数可自动完成对象的初始化任务，全局对象和静态对象的构造函数在main()函数执行之前就被调用，局部静态对象的构造函数是当程序第一次执行到相应语句时才被调用。然而给出一个外部对象的引用性声明时，并不调用相应的构造函数，因为这个外部对象只是引用在其他地方声明的对象，并没有真正的创建一个对象。</p>
<p>C++的构造函数定义格式为：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;类名&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&lt;类名&gt; (参数表)</span><br><span class="line"><span class="comment">//...(还可以声明其它的成员函数)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;类名&gt; :: &lt;函数名&gt;(参数表) &#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="析构函数（这里只说C++的构造函数）"><li>析构函数（这里只说C++的构造函数）</li></h5><p>析构函数（destructor）与构造函数相反，当对象脱离其作用域的时候（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做“清理善后”的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）</p>
<p>以C++语言为例：[1]  析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显示的析构函数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;类名&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~&lt;类名&gt;();</span><br><span class="line">&#125;;</span><br><span class="line">&lt;类名&gt; :: ~x&lt;类名&gt;() &#123;</span><br><span class="line">	<span class="comment">//函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当程序中没有析构函数时，系统会自动生成以下析构函数：<br>&lt;类名&gt; :: ~&lt;类名&gt;(){}，即不执行任何操作。</p>
<h5 id="不知道该起什么名字的什么鬼"><li>不知道该起什么名字的什么鬼</li></h5><p>刚刚犯了一个很低级的错误，让我们先看看代码吧＝＝。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Scene *Scene<span class="tag">::create</span>() &#123;</span><br><span class="line">	Scene *pRet = <span class="literal">new</span> Scene();</span><br><span class="line">	<span class="keyword">if</span> (pRet <span class="subst">&amp;&amp;</span> pRet <span class="subst">-&gt; </span>init()); &#123;</span><br><span class="line">		pRet <span class="subst">-&gt; </span>autorelease()</span><br><span class="line">		<span class="keyword">return</span> pRet;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	CC_SAFE_DELETE(pRet);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始我在想<code>Scene *Scene::create() {}</code>这句话是什么意思。我理解了半天都理解成了*Scene::create()这个类的create()方法。后来发现并不是这样！这句话明明这样写才比较好吧！<code>Scene * Scene::create() {}</code>也就是说这个和<code>int * foo() {}</code>即函数返回一个指针。</p>
<h5 id="Vector"><li>Vector</li></h5><p>封装了C++的vector容器类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> HelloWorld::init() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Layer::init()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*-----Vector的简单使用-----*/</span></span><br><span class="line">    <span class="comment">//创建2个小若</span></span><br><span class="line">    </span><br><span class="line">    Label * label1 = Label::create(<span class="string">"sakuraNo.1"</span>, <span class="string">"Arial"</span>, <span class="number">30</span>);</span><br><span class="line">    label1 -&gt; setPosition(Point(<span class="number">250</span>, <span class="number">400</span>));</span><br><span class="line">    </span><br><span class="line">    Label * label2 = Label::create(<span class="string">"sakuraNo.2"</span>, <span class="string">"Arial"</span>, <span class="number">30</span>);</span><br><span class="line">    label2 -&gt; setPosition(Point(<span class="number">250</span>, <span class="number">400</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建Vector对象</span></span><br><span class="line">    Vector&lt;Label*&gt; vec;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把两个Label存放倒Vector中</span></span><br><span class="line">    vec.pushBack(label1);</span><br><span class="line">    vec.pushBack(label2);</span><br><span class="line">    <span class="comment">//遍历Vector, 取出所有Label,添加场景</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> lab : vec) &#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; addChild(lab);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><li>创建两个Label,先不添加场景；<br></li></p>
<p><li>创建Vector对象，/&lt;&gt;里的Label*代表的是这个Vector对象只能存放Label对象，其他的一概拒绝；<br></li></p>
<p><li>调用Vector的pushBack函数，把两个Label对象依次添加到队列的尾部；<br></li></p>
<p><li>利用for(auto lab : vec)可以遍历Vector队列中的每一个对象，然后获取到所有的Label对象，并添加到场景里<br></li></p>
<h5 id="Map"><li>Map</li></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> HelloWorld::init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Layer::init()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建Map对象</span></span><br><span class="line">    Map&lt;<span class="keyword">int</span>, Label*&gt; SakuraMap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一百个Sakura,并保存到Map中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//组合名字</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">"SakuraNo."</span> + Value(i).asString();</span><br><span class="line">        <span class="comment">//创建Label对象,代表Sakura</span></span><br><span class="line">        Label* lab = Label::create(name.c_str(), <span class="string">"Arial"</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="comment">//保存到Map中，用i作为key,用lab作为value</span></span><br><span class="line">        SakuraMap.insert(i, lab);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Label* sakuraLab = SakuraMap.at(<span class="number">26</span>);</span><br><span class="line">    sakuraLab -&gt; setPosition(Point(<span class="number">200</span>, <span class="number">200</span>));</span><br><span class="line">    <span class="keyword">this</span> -&gt; addChild(sakuraLab);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><li>创建一个Map对象，Map<int, label*="">的意思是，这个Map使用int类型作为key值，使用Label类型作为value值，以后通过key值可以快速取出value值。<br></int,></li></p>
<p><li>创建100个Label对象，代表sakura，保存到Map中，Map的insert函数就是做这个工作的。第一个参数是key的值，以后使用这个key值来获取对象；第二个餐素是我们要保存的对象。<br></li></p>
<p><li>选定一个key值，/<strong>使用at函数就能Map中取出这个key值对应的Label对象</strong>/<br></li></p>
<p><li>将取出的Label对象添加到场景中<br></li></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-HTTP 服务器与客户端" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/11/HTTP 服务器与客户端/" class="article-date">
  	<time datetime="2015-11-11T10:38:35.000Z" itemprop="datePublished">2015-11-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/11/HTTP 服务器与客户端/">Node.js HTTP 服务器与客户端</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="HTTP服务器与客户端">HTTP服务器与客户端</h3><p>Node.js标准库提供了http模块，其中封装了一个高效的HTTP服务器和一个简易的HTTP客户端。http.Server是一个基于事件的HTTP服务器，它的核心由Node.js下层部分实现，而接口由JavaScript封装，兼顾了高性能与建议性。</p>
<h4 id="HTTP服务器">HTTP服务器</h4><p>http.Server是http模块中的HTTP服务器对象。用Node.js做的所有基于HTTP服务器协议的系统，如网站，社交应用甚至代理服务器，都是基于http.Server实现的。它提供了一套封装级别很低的API，仅仅是流控制和简单的消息解析，所有的高层功能都是通过它的接口来实现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 张仲昊
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>